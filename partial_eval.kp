(with_import "./collections.kp"
(let (
    ; This partial eval only works via the root env,
    ; since we can't tell from outside if something takes an env
    ; or not
    ; Also, based on that, we have to switch on every primitive...


    ; Here is every form in k'
    ; True
    ; False
    ; Env: *KPEnv
    ; Combiner: KPCombiner / BuiltinCombiner: KPBuiltinCombiner
    ; String: str
    ; Symbol: str
    ; Int: int
    ; Array: rc<vec<KPValue>>
    ; Nil


    ; Ok, some more things we need / need to change

    ; meta...

    ; Env will need special checking for escaping, including when contained inside of an array or other combinator
    ; Actually, that extends to checking escaping for combinators in general, since they may close over laters

    ; Ok, instead of just ['now v] and ['later v], we have these marked values
    ; ['val v] (v can be an array)
    ; ['later c]
    ; ['marked_array a] (a contains marked values)
    ; ['comb wrap_level de? se params body <actual_function>]
    ; ['prim_comb <handler_function> <actual_function>]
    ; ['env [ ['symbol marked_value ]... ] <actual_env>]


    val? (lambda (x) (= 'val (idx x 0)))
    .val (lambda (x) (idx x 1))
    later? (lambda (x) (= 'later (idx x 0)))
    .later (lambda (x) (idx x 1))
    marked_array? (lambda (x) (= 'marked_array (idx x 0)))
    comb? (lambda (x) (= 'comb (idx x 0)))
    .comb (lambda (x) (slice x 1 -1))
    prim_comb? (lambda (x) (= 'prim_comb (idx x 0)))
    .prim_comb (lambda (x) (idx x 1))
    marked_env? (lambda (x) (= 'env (idx x 0)))
    .env_marked (lambda (x) (idx x 1))
    .env_real (lambda (x) (idx x 2))

    strip (rec-lambda recurse (x)
        (cond (val? x)          (.val x)
              (later? x)        (.later x)
              (marked_array? x) (map recurse (idx x 1))
              (comb? x)         (idx x 6)
              (prim_comb? x)    (idx x 2)
              (makred_env? x)   (error "Env escaped to strip!")
        )
    )

    ; GAH ok additionally
    ; partial_eval_helper will have to deal with combinator values (at least, primitives, I suspect all)
    ; as it might have to use them to reconstruct an expression on strip,
    ; and we will have to partially-eval previously strip'ped expressions when
    ; calling functions whose definition we partially-evaled, etc.
    ; partial_eval_helper always takes in unmarked expressions and makes marked ones, maintaining marked envs
    ;
    ; If indeed we have to keep track of non-primitive combinator values (which I think makes sense for stripping),
    ; we'll have to continually keep a map
    ; of values to their definition.

    partial_eval_helper (rec-lambda recurse (x env comb_to_mark_map)
        (cond   (= x true)                      [comb_to_mark_map ['val true ]]
                (= x false)                     [comb_to_mark_map ['val false]]
                (env? x)                        (error "called partial_eval with an env " x)
                (combiner? x)                   (error "called partial_eval with a combiner, not yet supported (assuming just parsed symbols etc) " x)
                (string? x)                     [comb_to_mark_map ['val x]]
                (symbol? x)                     [comb_to_mark_map (get-value (.env_marked env) x)]
                (int? x)                        [comb_to_mark_map ['val x]]
                (and (array? x) (= 0 (len x)))  (error "Partial eval on empty array")
                (array? x)                      (let ( [comb_to_mark_map comb] (recurse (idx x 0) env comb_to_mark_map) )
                                                     (cond (later? comb)     [comb_to_mark_map ['later x]]
                                                           (prim_comb? comb) ((.prim_comb comb) env comb_to_mark_map (slice x 1 -1))
                                                           (comb? comb)      (let (
                                                                                 [wrap_level de? se params body actual_function] (.comb comb)
                                                                                    ; Env will need special checking for escaping, including when contained inside of an array or other combinator
                                                                                    ; Actually, that extends to checking escaping for combinators in general, since they may close over laters
                                                                                 ;subs (map (lambda (y) (recurse y env comb_to_mark_map)) x)
                                                                             ) [comb_to_mark_map ['later x]])
                                                           true              (error (str "Partial eval noticed that you will likely call not a function " x))))
                (nil? x)                        [comb_to_mark_map ['val x]]

        )
    )
    needs_params_val_lambda (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (lambda (de comb_to_mark_map params) (let (
                [comb_to_mark_map evaled_params] (map (lambda (x) (partial_eval_helper x de comb_to_mark_map)) params)
                [comb_to_mark_map evaled_params] (foldl (lambda ([comb_to_mark_map evaleds] x) (let (
                                                                     [comb_to_mark_map evaled] (partial_eval_helper x de comb_to_mark_map)
                                                                 ) [comb_to_mark_map (cons evaled evaleds)])) [comb_to_mark_map []] params)
            )
            (if (foldl (lambda (a x) (and a (val? x))) true evaled_params) [comb_to_mark_map ['val (lapply actual_function (map .val evaled_params))]]
                                                                           [comb_to_mark_map ['later (cons actual_function params)]])))
        ) [f_sym ['prim_comb handler actual_function]]))
    give_up (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (lambda (de comb_to_mark_map params) [comb_to_mark_map ['later (cons actual_function params)]])
        ) [f_sym ['prim_comb handler actual_function]]))

    root_marked_env ['env [
        ; Ok, so for combinators, it should partial eval the body.
        ; It should then check to see if the partial-evaled body has closed over
        ; any 'later values from above the combinator. If so, the combinator should
        ; evaluate to a ['later [vau de? params (strip partially_evaled_body)]], otherwise it can evaluate to a 'comb.
        ; Note that this 'later may be re-evaluated later if the parent function is called.
        (give_up vau)

        ; eval should have it's parameters partially -evaled, then partially-eval e again.
        ; failure can 'later at either point
        (give_up eval)
        (give_up cond)
        (needs_params_val_lambda symbol?)
        (needs_params_val_lambda int?)
        (needs_params_val_lambda string?)
        (give_up combiner?)
        (give_up env?)
        (needs_params_val_lambda nil?)
        (needs_params_val_lambda bool?)
        (give_up array?)
        (needs_params_val_lambda str-to-symbol)
        (needs_params_val_lambda get-text)
        (give_up array)
        (give_up len)
        (give_up idx)
        (give_up slice)
        (give_up concat)
        (needs_params_val_lambda +)
        (needs_params_val_lambda -)
        (needs_params_val_lambda *)
        (needs_params_val_lambda /)
        (needs_params_val_lambda %)
        (needs_params_val_lambda &)
        (needs_params_val_lambda |)
        (needs_params_val_lambda <<)
        (needs_params_val_lambda >>)
        (needs_params_val_lambda =)
        (needs_params_val_lambda !=)
        (needs_params_val_lambda <)
        (needs_params_val_lambda <=)
        (needs_params_val_lambda >)
        (needs_params_val_lambda >=)

        ; Don't forget, these short-circut with the truthy/falsey values
        (give_up and)
        (give_up or)

        ; pr-str
        (needs_params_val_lambda str)
        (needs_params_val_lambda prn)
        (give_up println)
        (give_up meta)
        (give_up with-meta)
        (give_up wrap)
        (give_up unwrap)
        (give_up error)
        (give_up recover)
        (give_up read-string)
        (give_up slurp)
        (give_up get_line)
        (give_up write_file)
        ['empty_env ['env [] empty_env]]
    ] root_env]

    comb_to_mark_map (foldl (lambda (a x) (cond (comb?      (idx x 1)) (put a (idx (idx x 1) 6) (idx x 1))
                                                (prim_comb? (idx x 1)) (put a (idx (idx x 1) 2) (idx x 1))
                                                true                   a
                                          ) ) empty_dict (idx root_marked_env 1))
    partial_eval (lambda (x) (partial_eval_helper x root_marked_env comb_to_mark_map))
)
    (provide partial_eval strip)
))
