(with_import "./collections.kp"
(let (
    ; For right now we only support calling partial_eval in such a way that it partial evals against
    ; the root env, but this is could and really should be extended. We could at least check if the env we're called with
    ; is the root_env, or if what we look up in whatever env is passed in matches something in the root env
    ; Care should also be taken when evaluating outside combinators to have them be in the right env, etc

    ; Here is every form in k'
    ; True
    ; False
    ; Env: *KPEnv
    ; Combiner: KPCombiner / BuiltinCombiner: KPBuiltinCombiner
    ; String: str
    ; Symbol: str
    ; Int: int
    ; Array: rc<vec<KPValue>>
    ; Nil


    ; Ok, some more things we need / need to change
    ;   1) meta...
    ;        Honestly, I'm tempted to get rid of it

    ; !!!!!!!!!!!!!!!!!!!!!!!!!!
    ; ! To avoid exponential blowup due to evaluating function, then params, then function with params, etc etc
    ; ! Should probabally implement some form of evaluating to head-normal form controlled by boolean
    ; ! that quits as soon as it has any sort of value (I suppose the real change is only to combinators and arrays)
    ; ! so that we don't waste time re-trying etc. Anything in parameter position would be fully evaluated, so I don't think
    ; ! we'd waste overmuch, but it could make things less efficient I suppose...
    ; ! Maybe it's a bad idea - food for thought! Might need a better cacheing strategy
    ; !!!!!!!!!!!!!!!!!!!!!!!!!

    ; Possible marked values
    ; ['val v]                  - v is a value that evaluates to itself, and not a combiner or env, as those have their own metadata. Not an array or symbol
    ;                               That means it's true/false/a string/ an int/nil
    ; ['marked_array is_val a]  - a contains marked values. if is_val, then it's the value version, and must be stripped back into (array ...),
    ;                               otherwise it's a calling form, and should be lowered back to (...). Also, if it's is_val, partial_eval won't perform a call, etc
    ; ['marked_symbol is_val s] - a symbol. is_val has the same meaning as in marked_array
    ; ['comb wrap_level de? se variadic params body <actual_function>] - A combiner. Contains the static env and the actual function, if possible.
    ;                                                                    It is possible to have a combiner without an actual function, but that's only generated when
    ;                                                                    we know it's about to be called and we won't have to strip-lower it
    ; ['prim_comb <handler_function> <actual_function>]                     - A primitive combiner! It has it's own special handler function to partial eval
    ; ['env [ ['symbol marked_value ]... <upper_marked_env> ] <actual_env>] - A marked env


    val? (lambda (x) (= 'val (idx x 0)))
    .val (lambda (x) (idx x 1))
    marked_array? (lambda (x) (= 'marked_array (idx x 0)))
    .marked_array_is_val (lambda (x) (idx x 1))
    .marked_array_values (lambda (x) (idx x 2))
    marked_symbol? (lambda (x) (= 'marked_symbol (idx x 0)))
    .marked_symbol_is_val (lambda (x) (idx x 1))
    .marked_symbol_value  (lambda (x) (idx x 2))
    later? (lambda (x) (or (and (marked_array? x)  (= false (.marked_array_is_val x)))
                           (and (marked_symbol? x) (= false (.marked_symbol_is_val x)))))
    false? (lambda (x) (cond (and (marked_array? x)  (= false (.marked_array_is_val x)))    (error (str "got a later marked_array passed to false? " x))
                             (and (marked_symbol? x) (= false (.marked_symbol_is_val x)))   (error (str "got a later marked_symbol passed to false? " x))
                             (val? x)                                                       (not (.val x))
                             true                                                           false))
    comb? (lambda (x) (= 'comb (idx x 0)))
    .comb (lambda (x) (slice x 1 -1))
    prim_comb? (lambda (x) (= 'prim_comb (idx x 0)))
    .prim_comb (lambda (x) (idx x 1))
    marked_env? (lambda (x) (= 'env (idx x 0)))
    .env_marked (lambda (x) (idx x 1))
    .env_real (lambda (x) (idx x 2))

    env-lookup-helper (rec-lambda recurse (dict key i fail success) (cond (and (= i (- (len dict) 1)) (= nil (idx dict i)))  (fail)
                                                                          (= i (- (len dict) 1))                             (recurse (idx (idx dict i) 1) key 0 fail success)
                                                                          (= key (idx (idx dict i) 0))                       (success (idx (idx dict i) 1))
                                                                          true                                               (recurse dict key (+ i 1) fail success)))
    env-lookup (lambda (env key) (env-lookup-helper (idx env 1) key 0 (lambda () (error (str key " not found in env " (idx env 1)))) (lambda (x) x)))

    mark (rec-lambda recurse (x) (cond   (env? x)        (error (str "called mark with an env " x))
                                         (combiner? x)   (error (str "called mark with a combiner " x))
                                         (symbol? x)     ['marked_symbol false x]
                                         (array? x)      ['marked_array false (map recurse x)]
                                         true            ['val x]))

    strip (rec-lambda recurse (x)
        (cond (val? x)           (.val x)
              (marked_array? x)  (let (stripped_values (map recurse (.marked_array_values x)))
                                      (if (.marked_array_is_val x) (cons array stripped_values)
                                                                   stripped_values))
              (marked_symbol? x) (if (.marked_symbol_is_val x) [quote (.marked_symbol_value x)]
                                                               (.marked_symbol_value x))
              (comb? x)          (let (c (idx x 7))
                                      (if (= nil c) (error (str "partial eval failed: regular stripping a combinator without a real combinator (due to nil enviornment, no doubt, but how?)" x))
                                                    c))
              (prim_comb? x)     (idx x 2)
              (marked_env? x)    (error "Env escaped to strip!")
              true               (error (str "some other strip? " x))
        )
    )

    print_strip (lambda (x) (println ((rec-lambda recurse (x)
        (cond (val? x)           (.val x)
              (marked_array? x)  (let (stripped_values (map recurse (.marked_array_values x)))
                                      (if (.marked_array_is_val x) (cons array stripped_values)
                                                                   stripped_values))
              (marked_symbol? x) (if (.marked_symbol_is_val x) [quote (.marked_symbol_value x)]
                                                               (.marked_symbol_value x))
              (comb? x)          (let ([wrap_level de? se variadic params body actual_function] (.comb x)) (str "<comb " wrap_level " " params " " (recurse body) ">"))
              (prim_comb? x)     (idx x 2)
              (marked_env? x)    (error "Env escaped to strip!")
              true               (error (str "some other strip? " x))
        )
    ) x)))

    ; A bit wild, but what if instead of is_value we had an evaluation level integer, kinda like wrap?
    ; when lowering, it could just turn into multiple evals or somesuch, though we'd have to be careful of envs...
    try_unval (rec-lambda recurse (x fail_f) (let (_ (println "try_unvaling " x) r
        (cond (marked_array? x) (if (not (.marked_array_is_val x)) [false (fail_f x)]
                                                                   (let ([sub_ok subs] (foldl (lambda ([ok a] x) (let ([nok p] (recurse x fail_f))
                                                                                                                      [(and ok nok) (concat a [p])]))
                                                                                              [true []]
                                                                                              (.marked_array_values x)))
                                                                        [sub_ok ['marked_array false subs]]))
              (marked_symbol? x) (if (.marked_symbol_is_val x) [true ['marked_symbol false (.marked_symbol_value x)]]
                                                               [false (fail_f x)])
              true               [true x]
        ) _ (println "\tresult was " r)) r)
    )
    try_unval_array (lambda (x) (foldl (lambda ([ok a] x) (let ([nok p] (try_unval x (lambda (_) nil)))
                                                               [(and ok nok) (concat a [p])]))
                                       [true []]
                                       x))

    ensure_val (rec-lambda recurse (x) (let (_ (println "ensure_valing " x) r
        (cond (marked_array? x)  ['marked_array true (map recurse (.marked_array_values x))]
              (marked_symbol? x) ['marked_symbol true (.marked_symbol_value x)]
              true               x
        ) _ (println "\tresult was " r)) r)
    )

    ; This is a conservative analysis, since we can't always tell what constructs introduce
    ; a new binding scope & would be shadowing... we should at least be able to implement it for
    ; vau/lambda, but we won't at first
    in_array (let (helper (rec-lambda recurse (x a i) (cond (= i (len a))   false
                                                            (= x (idx a i)) true
                                                            true            (recurse x a (+ i 1)))))
                  (lambda (x a) (helper x a 0)))
    contains_symbols (rec-lambda recurse (stop_envs symbols x) (cond
              (val? x)           false
              (marked_symbol? x) (in_array (.marked_symbol_value x) symbols)
              (marked_array? x)  (foldl (lambda (a x) (or a (recurse stop_envs symbols x))) false (.marked_array_values x))
              (comb? x)          (let ([wrap_level de? se variadic params body actual_function] (.comb x))
                                      (or (recurse stop_envs symbols se) (recurse stop_envs (filter (lambda (y) (not (in_array y params))) symbols) body)))

              (prim_comb? x)    false
              (marked_env? x)   (let (inner (.env_marked x))
                                     (cond (in_array x stop_envs)                                                                       false
                                           (foldl (lambda (a x) (or a (recurse stop_envs symbols (idx x 1)))) false (slice inner 0 -2)) true
                                           (idx inner -1)                                                                     (recurse stop_envs symbols (idx inner -1))
                                           true                                                                                         false))
              true              (error (str "Something odd passed to contains_symbols " x))
    ))

    indent_str (rec-lambda recurse (i) (if (= i 0) ""
                                                   (str "   " (recurse (- i 1)))))



    partial_eval_helper (rec-lambda recurse (x env imm_eval indent)
        (cond   (val? x)            x
                (marked_env? x)     x
                (comb? x)           x
                (prim_comb? x)      x
                (marked_symbol? x)  (if (.marked_symbol_is_val x) x
                                                                  (env-lookup env (.marked_symbol_value x)))
                (marked_array? x)   (cond (.marked_array_is_val x) x
                                          (= 0 (len (.marked_array_values x))) (error "Partial eval on empty array")
                                          true (let (values (.marked_array_values x)
                                                      _ (println (indent_str indent) "partial_evaling comb " (idx values 0))
                                                     comb (recurse (idx values 0) env true (+ 1 indent))
                                                     literal_params (slice values 1 -1)
                                                      _ (println (indent_str indent) "Going to do an array call!")
                                                      _ (println (indent_str indent) "     total is " x)
                                                      _ (println (indent_str indent) "     evaled comb is  " comb)
                                                      ident (+ 1 indent)
                                                     )
                                                                             ; Replacing the old note here with one that mentions that
                                                                             ; we use the imm_eval to know if it's ok to generate
                                                                             ; comb's without a real combiner (because it doesn't have a real env)
                                                                             ; because in the imm_eval case we don't need a real combiner since
                                                                             ; we're about to partial eval the call away
                                                     (cond (later? comb)     ['marked_array false (cons comb literal_params)]
                                                           (prim_comb? comb) ((.prim_comb comb) env literal_params imm_eval (+ 1 indent))
                                                           (comb? comb)      (let (
                                                                                 rp_eval (lambda (p) (recurse p env false (+ 1 indent)))
                                                                                 [wrap_level de? se variadic params body actual_function] (.comb comb)
                                                                                 ensure_val_params (map ensure_val literal_params)
                                                                                 _ (println (indent_str indent) "partial_evaling params with wrap level " wrap_level " " ensure_val_params)
                                                                                 [ok appropriatly_evaled_params] ((rec-lambda param-recurse (wrap cparams)
                                                                                        (if (!= 0 wrap)
                                                                                            (let (pre_evaled (map rp_eval cparams)
                                                                                                  [ok unval_params] (try_unval_array pre_evaled))
                                                                                                 (if (not ok) [ok nil]
                                                                                                    (let (evaled_params (map rp_eval unval_params))
                                                                                                         (param-recurse (- wrap 1) evaled_params))))
                                                                                            [true cparams])
                                                                                    ) wrap_level ensure_val_params)
                                                                                 ) (if (not ok) ['marked_array false (cons comb (if (> wrap_level 0) (map rp_eval literal_params)
                                                                                                                                                     literal_params))]
                                                                                 (let (
                                                                                 final_params (if variadic (concat (slice appropriatly_evaled_params 0 (- (len params) 1))
                                                                                                                   [['marked_array true (slice appropriatly_evaled_params (- (len params) 1) -1)]])
                                                                                                           appropriatly_evaled_params)
                                                                                 de_entry (if (!= nil de?) [ [de? env] ] [])
                                                                                 _ (println (indent_str indent) "final_params params " final_params)
                                                                                 de_real_entry (if (!= nil de?) [ [de? (.env_real env)] ] [])
                                                                                 se_real_env (.env_real se)
                                                                                 inner_real_env (if (and se_real_env (or (not de?) (.env_real env)))
                                                                                                    (add-dict-to-env se_real_env
                                                                                                                     (concat (zip params (map strip final_params))
                                                                                                                             de_real_entry))
                                                                                                    nil)
                                                                                 _ (println (indent_str indent) "Inner_real_env is " inner_real_env " because de_real " de_real_entry " se_real_env " se_real_env)
                                                                                 inner_env ['env (concat (zip params final_params) de_entry [se]) inner_real_env]
                                                                                 _ (println (indent_str indent) "going to eval " body " with inner_env is " inner_env)


                                                                                 ; Ok, this might be a later with un-evaled references to parameter symbols,
                                                                                 ; in which case we need to re-wrap up in a vau, since
                                                                                 ; if they're used as parameters to a 'later value that might be a vau,
                                                                                 ; since we don't know if they have to be evaluated and thus
                                                                                 ; can't partially evaluate them.
                                                                                 ; !!! I belive this can be modified to wrap up into a specialized version of the func though
                                                                                 ; !!! and indeed that might be the right option for vaus
                                                                                 ; !!! something like (if (= 0 wrap_level) ['marked_array false (cons ['comb wrap_level de? se variadic params func_result nil] literal_params)]
                                                                                 ; !!! but have to be careful about what real_function should be

                                                                                 _ (println (indent_str indent) "partial_evaling body " body)
                                                                                 func_result (recurse body inner_env imm_eval (+ 1 indent))

                                                                                 _ (println (indent_str indent) "evaled result of function call (imm_eval was " imm_eval ")  is " func_result)
                                                                                 result_is_later (later? func_result)
                                                                                 stop_envs ((rec-lambda ser (a e) (if e (ser (cons e a) (idx (.env_marked e) -1)) a)) [] se)
                                                                                 result_closes_over (contains_symbols stop_envs (concat params (if de? [de?] [])) func_result)
                                                                                 _ (println (indent_str indent) "func call result is later? " result_is_later " and result_closes_over " result_closes_over)
                                                                                 result (if (and result_is_later result_closes_over)
                                                                                                ; this is exponential-y - we retry without imm to see if we can
                                                                                                ; have a better partial eval'd later instead of giving up entirely
                                                                                                (let (
                                                                                                     _ (println (indent_str indent) "partial_evaling retrying comb and parameters after fail b/c result_is_later and result_closes_over " (idx values 0) " with wrap_level " wrap_level " and params " literal_params)
                                                                                                     comb (recurse (idx values 0) env false (+ 1 indent)))
                                                                                                     ['marked_array false (cons comb (if (> wrap_level 0) (map rp_eval ensure_val_params)
                                                                                                                                                    literal_params))])
                                                                                                func_result)
                                                                             ) result)))
                                                           true              (error (str "Partial eval noticed that you will likely call not a function " comb  " total is " x)))))
                true                (error (str "impossible partial_eval value " x))
        )
    )
    is_all_values (lambda (evaled_params) (foldl (lambda (a x) (and a (not (later? x)))) true evaled_params))
    needs_params_val_lambda (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (rec-lambda recurse (de params imm_eval indent) (let (
                _ (println "partial_evaling params in need_params_val_lambda for " f_sym " is " params)
                evaled_params (map (lambda (p) (partial_eval_helper p de false (+ 1 indent))) params)
            )
            (if (is_all_values evaled_params) (mark (lapply actual_function (map strip evaled_params)))
                                              ['marked_array false (cons ['prim_comb recurse actual_function] evaled_params)])))
        ) [f_sym ['prim_comb handler actual_function]]))
    give_up_eval_params (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (rec-lambda recurse (de params imm_eval indent) (let (
                _ (println "partial_evaling params in give_up_eval_params for " f_sym " is " params)
                evaled_params (map (lambda (p) (partial_eval_helper p de false (+ 1 indent))) params)
            )
            ['marked_array false (cons ['prim_comb recurse actual_function] evaled_params)]))
        ) [f_sym ['prim_comb handler actual_function]]))

    ; !!!!!!
    ; ! I think needs_params_val_lambda should be combined with parameters_evaled_proxy
    ; !!!!!!
    parameters_evaled_proxy (rec-lambda recurse (pasthr_ie inner_f) (lambda (de params imm_eval indent) (let (
        _ (println "partial_evaling params in parameters_evaled_proxy is " params)
        [evaled_params l] (foldl (lambda ([ac i] p) (let (p (partial_eval_helper p de (if (= i pasthr_ie) imm_eval false) (+ 1 indent)))
                                                         [(concat ac [p]) (+ i 1)]))
                                 [[] 0]
                                 params)
    ) (inner_f (lambda (& args) (lapply (recurse pasthr_ie inner_f) args)) de evaled_params imm_eval indent))))

    root_marked_env ['env [
        ; Ok, so for combinators, it should partial eval the body.
        ; It should then check to see if the partial-evaled body has closed over
        ; any 'later values from above the combinator. If so, the combinator should
        ; evaluate to a ['later [vau de? params (strip partially_evaled_body)]], otherwise it can evaluate to a 'comb.
        ; Note that this 'later may be re-evaluated later if the parent function is called.
        ['vau ['prim_comb (rec-lambda recurse (de params imm_eval indent) (let (
            mde?         (if (= 3 (len params)) (idx params 0))
            vau_mde?     (if (= nil mde?) [] [mde?])
            de?          (if mde? (.marked_symbol_value mde?))
            vau_de?      (if (= nil de?) [] [de?])
            raw_marked_params (if (= nil de?) (idx params 0) (idx params 1))
            raw_params (map (lambda (x) (if (not (marked_symbol? x)) (error (str "not a marked symbol " x))
                                            (.marked_symbol_value x))) (.marked_array_values raw_marked_params))
            [variadic vau_params]  (foldl (lambda ([v a] x) (if (= x '&) [true a] [v (concat a [x])])) [false []] raw_params)
            body        (if (= nil de?) (idx params 1) (idx params 2))
            inner_env   ['env (concat (map (lambda (p) [p ['marked_symbol false p]]) vau_params) (if (= nil de?) [] [ [de? ['marked_symbol false de?]] ]) [de]) nil]
            _ (println (indent_str indent) "in vau, evaluating body with 'later params - " body)
            pe_body (partial_eval_helper body inner_env false (+ 1 indent))
            _ (println (indent_str indent) "in vau, result of evaluating body was " pe_body " stripping")
            for_later (= nil (.env_real de))
            _ (println (indent_str indent) "imm_eval is " imm_eval " and for_later is " for_later " for " params " because of env being null " de)
        ) (if for_later (if (not imm_eval) ['marked_array false (concat [['prim_comb recurse vau]] vau_mde? [raw_marked_params pe_body])]
                                           ['comb 0 de? de variadic vau_params pe_body nil])
                        (let (real_func (eval (concat [vau] vau_de? [raw_params (strip pe_body)]) (.env_real de))
                              marked_func ['comb 0 de? de variadic vau_params pe_body real_func]
                              _ (println (indent_str indent) "Marked func is " marked_func)
                              _ (println (indent_str indent) "Raw func was made with body " (strip pe_body))
                             ) marked_func)))
        ) vau]]

        ['wrap ['prim_comb (parameters_evaled_proxy 0 (lambda (recurse de [evaled] imm_eval indent)
              (if (comb? evaled) (let ([wrap_level de? se variadic params body actual_function] (.comb evaled)
                                        wrapped_actual_fun (if (= nil actual_function) nil (wrap actual_function))
                                        wrapped_marked_fun ['comb (+ 1 wrap_level) de? se variadic params body wrapped_actual_fun]
                                      ) wrapped_marked_fun)
                                 ['marked_array false [['prim_comb recurse wrap] evaled]]))
        ) wrap]]
        ['unwrap ['prim_comb (parameters_evaled_proxy 0 (lambda (recurse de [evaled] imm_eval indent)
             (if (comb? evaled) (let ([wrap_level de? se variadic params body actual_function] (.comb evaled)
                                        unwrapped_actual_fun (if (= nil actual_function) nil (unwrap actual_function))
                                        unwrapped_marked_fun ['comb (- wrap_level 1) de? se variadic params body unwrapped_actual_fun]
                                      ) unwrapped_marked_fun)
                                 ['marked_array false [['prim_comb recurse wrap] evaled]]))
        ) unwrap]]

        ['eval ['prim_comb (rec-lambda recurse (de params imm_eval indent) (let (
            self ['prim_comb recurse eval]
            _ (println "partial_evaling param 1 maybe in eval is (if it exists) " (if (= 2 (len params)) (idx params 1)))
            eval_env (if (= 2 (len params)) (partial_eval_helper (idx params 1) de false (+ 1 indent))
                                            de)
            eval_env_v (if (= 2 (len params)) [eval_env] [])
         ) (if (not (marked_env? eval_env)) ['marked_array false (cons self params)]
                                            (let (
            _ (println (indent_str indent) "ok, env was " eval_env " partial_evaling_body the first time")
            body1 (partial_eval_helper (idx params 0) de imm_eval (+ 1 indent))
            _ (println (indent_str indent) "after first eval of param " body1)

            ; With this, we don't actually fail as this is always a legitimate uneval
            fail_handler (lambda (failed) ['marked_array false (concat [self failed] eval_env_v)])
            [ok unval_body] (try_unval body1 fail_handler)
            self_fallback (fail_handler body1)
            _ (println "partial_evaling body for the second time in eval " unval_body)
            body2 (if (= self_fallback unval_body) self_fallback (partial_eval_helper unval_body eval_env imm_eval (+ 1 indent)))
            ;[ok unval_body] (try_unval body1 (lambda (failed) nil))
            ;body2 (if ok (partial_eval_helper unval_body eval_env imm_eval (+ 1 indent))
            ;             self_fallback)

            _ (println (indent_str indent) "and body2 is " body2)
            ) body2))
        )) eval]]

        ;TODO: This could go a lot farther, not stopping after the first 'later, etc
        ; Also, GAH on odd params - but only one by one - a later odd param can't be imm_eval cuz it will
        ; be frozen if an earlier cond is 'later....
        ['cond ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de evaled_params imm_eval indent)
            (if (!= 0 (% (len evaled_params) 2)) (error (str "partial eval cond with odd evaled_params " evaled_params))
                ((rec-lambda recurse_inner (i)
                                          (cond (later? (idx evaled_params i))  ['marked_array false (cons ['prim_comb recurse cond] (slice evaled_params i -1))]
                                                (false? (idx evaled_params i))  (recurse_inner (+ 2 i))
                                                true                            (idx evaled_params (+ 1 i))) ; we could partially_eval again passing in immediate
                                                                                                             ; eval if it was true, to partially counteract the above GAH
                 ) 0)
            )
        )) cond]]
        (needs_params_val_lambda symbol?)
        (needs_params_val_lambda int?)
        (needs_params_val_lambda string?)
        ; not even a gah, but kinda!
        ['combiner? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_param] imm_eval indent)
            (cond (comb? evaled_param)          ['val true]
                  (prim_comb? evaled_param)     ['val true]
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse combiner?] evaled_param]]
                  true                          ['val false]
            )
        )) combiner?]]
        ; not even a gah, but kinda!
        ['env? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_param] imm_eval indent)
            (cond (marked_env? evaled_param)    ['val true]
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse env?] evaled_param]]
                  true                          ['val false]
            )
        )) env?]]
        (needs_params_val_lambda nil?)
        (needs_params_val_lambda bool?)
        (needs_params_val_lambda str-to-symbol)
        (needs_params_val_lambda get-text)
        ['array? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_param] imm_eval indent)
            (cond 
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse array?] evaled_param]]
                  (marked_array? evaled_param)  ['val true]
                  true                          ['val false]
            )
        )) array?]]
        ['array ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de evaled_params imm_eval indent)
                                                ['marked_array true evaled_params]
        )) array]]
        ['len ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_param] imm_eval indent)
            (cond (later? evaled_param)         ['marked_array false [['prim_comb recurse len] evaled_param]]
                  (marked_array? evaled_param)  ['val (len (.marked_array_values evaled_param))]
                  true                          (error (str "bad type to len " evaled_param))
            )
        )) len]]
        ['idx ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_array evaled_idx] imm_eval indent)
            (cond (and (val? evaled_idx) (marked_array? evaled_array) (.marked_array_is_val evaled_array)) (idx (.marked_array_values evaled_array) (.val evaled_idx))
                  true                                                                                     ['marked_array false [['prim_comb recurse idx] evaled_array evaled_idx]]
            )
        )) idx]]
        ['slice ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de [evaled_array evaled_begin evaled_end] imm_eval indent)
            (cond (and (val? evaled_begin) (val? evaled_end) (marked_array? evaled_array) (.marked_array_is_val evaled_array))
                            ['marked_array true (slice (.marked_array_values evaled_array) (.val evaled_begin) (.val evaled_end))]
                  true      ['marked_array false [['prim_comb recurse slice] evaled_array evaled_idx evaled_begin evaled_end]]
            )
        )) slice]]
        ['concat ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de evaled_params imm_eval indent)
            (cond (foldl (lambda (a x) (and a (and (marked_array? x) (.marked_array_is_val x))) true evaled_params) ['marked_array true (lapply concat (map (lambda (x)
                                                                                                                                                             (.marked_array_values x))
                                                                                                                                                            evaled_params))]
                  true                                                                                              ['marked_array false (cons ['prim_comb recurse concat] evaled_params)]
            )
        ))) concat]]
        (needs_params_val_lambda +)
        (needs_params_val_lambda -)
        (needs_params_val_lambda *)
        (needs_params_val_lambda /)
        (needs_params_val_lambda %)
        (needs_params_val_lambda &)
        (needs_params_val_lambda |)
        (needs_params_val_lambda <<)
        (needs_params_val_lambda >>)
        (needs_params_val_lambda =)
        (needs_params_val_lambda !=)
        (needs_params_val_lambda <)
        (needs_params_val_lambda <=)
        (needs_params_val_lambda >)
        (needs_params_val_lambda >=)

        ; these could both be extended to eliminate other known true values except for the end and vice-versa
        ['and ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de evaled_params imm_eval indent)
            ((rec-lambda inner_recurse (i)
                                      (cond (= i (- (len evaled_params) 1))          (idx evaled_params i)
                                            (later? (idx evaled_params i))           ['marked_array false (cons ['prim_comb recurse and] (slice evaled_params i -1))]
                                            (false? (idx evaled_params i))           (idx evaled_params i)
                                            true                                     (inner_recurse (+ 1 i)))
             ) 0)
        )) and]]
        ; see above for improvement
        ['or ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de evaled_params imm_eval indent)
            ((rec-lambda inner_recurse (i)
                                      (cond (= i (- (len evaled_params) 1))          (idx evaled_params i)
                                            (later? (idx evaled_params i))           ['marked_array false (cons ['prim_comb recurse or] (slice evaled_params i -1))]
                                            (false? (idx evaled_params i))           (recurse (+ 1 i))
                                            true                                     (idx evaled_params i))
             ) 0)
        )) or]]
        ; should make not a built in and then do here
        ; OR not - I think it will actually lower correctly partially evaled

        (needs_params_val_lambda pr-str)
        (needs_params_val_lambda str)
        (needs_params_val_lambda prn)
        (give_up_eval_params println)
        ; really do need to figure out if we want to keep meta, and add it if so
        (give_up_eval_params meta)
        (give_up_eval_params with-meta)
        ; if we want to get fancy, we could do error/recover too
        (give_up_eval_params error)
        (give_up_eval_params recover)
        (needs_params_val_lambda read-string)
        (give_up_eval_params slurp)
        (give_up_eval_params get_line)
        (give_up_eval_params write_file)
        ['empty_env ['env [] empty_env]]
        nil
    ] root_env]

    partial_eval (lambda (x) (partial_eval_helper (mark x) root_marked_env false 0))
)
    (provide partial_eval strip print_strip)
))
