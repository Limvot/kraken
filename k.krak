import io:*
import grammer:*
import lexer:*
import parser:*
import str:*
import serialize:*
import os:*
import set:*
import stack:*
import vec:*
import vec_literals:*
import poset:*
import util:*
import ast:*
import type2:*
import tree:*
import symbol:*
import binding:*

adt OptionVecAst {
    Some: vec<*tree<ast>>,
    None
}

fun main(argc: int, argv: **char): int {
    // delay construction until we either load it or copy construct it
    var gram: grammer
    var base_dir = str("/").join(str(argv[0]).split('/').slice(0,-2))
    var import_paths =  vec(str(), base_dir + "/stdlib/")
    var file_name = base_dir + "/krakenGrammer.kgm"
    var compiled_name = file_name + str(".comp_new")
    var compiled_version = 1
    var file_contents = read_file(file_name)
    var loaded_and_valid = false

    if (argc <= 1) {
        println("No input file!\n Call with one argument (the input file), or two arguments (input file and output name)")
        exit(1)
    } else if (str(argv[1]) == "-v" || str(argv[1]) == "--version") {
        println("0.0 pre")
        exit(0)
    }
    var opt_str = str("-O2")
    var compile_c = true
    var positional_args = vec<str>()
    for (var i = 1; i < argc; i++;) {
        var arg_str = str(argv[i])
        if (arg_str.length() > 2 && arg_str.slice(0,2) == "-O") {
            opt_str = arg_str
        } else if (arg_str == "--no-c-compile") {
            compile_c = false
        } else {
            positional_args.add(arg_str)
        }
    }

    if (file_exists(compiled_name)) {
        var pos = 0
        var binary = read_file_binary(compiled_name)
        var saved_version = 0
        unpack(saved_version, pos) = unserialize<int>(binary, pos)
        if (saved_version == compiled_version) {
            var cached_contents = str()
            unpack(cached_contents, pos) = unserialize<str>(binary, pos)
            if (cached_contents == file_contents) {
                loaded_and_valid = true
                pos = gram.unserialize(binary, pos)
            } else println("contents different")
        } else println("version number different")
    } else {
        println("cached file does not exist")
    }
    if (!loaded_and_valid) {
        println("Not loaded_and_valid, re-generating and writing out")
        gram.copy_construct(&load_grammer(file_contents))
        println("grammer loaded, calculate_first_set")
        gram.calculate_first_set()
        println("grammer loaded, calculate_state_automaton")
        gram.calculate_state_automaton()
        println("calculated, writing out")
        write_file_binary(compiled_name, serialize(compiled_version) + serialize(file_contents) + serialize(gram))
        println("done writing")
    }

    var lex = lexer(gram.terminals)
    var parse.construct(&gram, &lex): parser

    var kraken_file_name = positional_args[0]
    var executable_name = str(".").join(kraken_file_name.split('.').slice(0,-2))
    if (positional_args.size > 1)
        executable_name = positional_args[1]

    var pass_poset = poset<pair<*tree<ast>, str>>()
    var name_ast_map = map<str, *tree<ast>>()
    var passes = map<str, fun(*tree<ast>): void>()

    var multiple_binding_options = map<*tree<ast>, vec<*tree<ast>>>()
    var primitive_ops.construct(): map<str, vec<*tree<ast>>>

    var number_tower = vec(binding_p(type::_char()),
                           binding_p(type::_uchar()),
                           binding_p(type::_short()),
                           binding_p(type::_ushort()),
                           binding_p(type::_int()),
                           binding_p(type::_uint()),
                           binding_p(type::_long()),
                           binding_p(type::_ulong()),
                           binding_p(type::_float()),
                           binding_p(type::_double()))
    var comparators = vec(str("=="), str("<="), str(">="), str("!="), str("<"), str(">"))
    for (var i = 0; i < comparators.size; i++;) {
        primitive_ops["op" + comparators[i]] = vec<*tree<ast>>()
        for (var j = 0; j < number_tower.size; j++;)
            for (var k = 0; k < number_tower.size; k++;)
                primitive_ops["op" + comparators[i]].add(_compiler_intrinsic(comparators[i], binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), number_tower[j]),
                                    make_pair(ref_type::_notref(), number_tower[k])
                                ),
                            make_pair(ref_type::_notref(), binding_p(type::_bool()))
                        ), false, false))), vec<*binding<type>>()))
    }
    var math = vec(str("+"), str("-"), str("*"), str("/"), str("&"), str("|"),  str("^"))
    for (var i = 0; i < math.size; i++;) {
        primitive_ops["op" + math[i]] = vec<*tree<ast>>()
        for (var j = 0; j < number_tower.size; j++;) {
            for (var k = 0; k < number_tower.size; k++;) {
                var return_type = null<binding<type>>()
                if (j > k) {
                    return_type = number_tower[j]
                } else {
                    return_type = number_tower[k]
                }
                primitive_ops["op" + math[i]].add(_compiler_intrinsic(math[i], binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), number_tower[j]),
                                    make_pair(ref_type::_notref(), number_tower[k])
                                ),
                            make_pair(ref_type::_notref(), return_type)
                        ), false, false))), vec<*binding<type>>()))
            }
        }
    }
    // cute hack for getting plain =
    math.add(str(""))
    for (var i = 0; i < math.size; i++;) {
        primitive_ops["op" + math[i] + "="] = vec<*tree<ast>>()
        for (var j = 0; j < number_tower.size; j++;) {
            for (var k = 0; k <= j; k++;) {
                var return_type = null<binding<type>>()
                primitive_ops["op" + math[i] + "="].add(_compiler_intrinsic(math[i] + "=", binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), number_tower[j]),
                                    make_pair(ref_type::_notref(), number_tower[k])
                                ),
                            make_pair(ref_type::_notref(), binding_p(type::_void()))
                        ), false, false))), vec<*binding<type>>()))
            }
        }
    }
    math.remove(math.size-1)

    // address of
    var template_type = binding_p(type::_template_placeholder())
    primitive_ops[str("op&")].add(_template(str("&"), map(str("T"), template_type), vec(_compiler_intrinsic(str("&"), binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), template_type)
                                ),
                            make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                        ), false, false))), vec<*binding<type>>()))))
    // dereference
    var template_type = binding_p(type::_template_placeholder())
    primitive_ops[str("op*")].add(_template(str("*"), map(str("T"), template_type), vec(_compiler_intrinsic(str("*"), binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                                ),
                            make_pair(ref_type::_notref(), template_type)
                        ), false, false))), vec<*binding<type>>()))))

    for (var i = 0; i < number_tower.size - 2; i++;) {
        var template_type = binding_p(type::_template_placeholder())
        primitive_ops[str("op+")].add(_template(str("+"), map(str("T"), template_type), vec(_compiler_intrinsic(str("+"), binding_p(type::_fun(make_triple(make_pair(vec(
                                        make_pair(ref_type::_notref(), number_tower[i]),
                                        make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                                    ),
                                make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                            ), false, false))), vec<*binding<type>>()))))
        primitive_ops[str("op+")].add(_template(str("+"), map(str("T"), template_type), vec(_compiler_intrinsic(str("+"), binding_p(type::_fun(make_triple(make_pair(vec(
                                        make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type))),
                                        make_pair(ref_type::_notref(), number_tower[i])
                                    ),
                                make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                            ), false, false))), vec<*binding<type>>()))))

        // note only ptr-1, not 1-ptr to match C...
        primitive_ops[str("op-")].add(_template(str("-"), map(str("T"), template_type), vec(_compiler_intrinsic(str("-"), binding_p(type::_fun(make_triple(make_pair(vec(
                                        make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type))),
                                        make_pair(ref_type::_notref(), number_tower[i])
                                    ),
                                make_pair(ref_type::_notref(), binding_p(type::_ptr(template_type)))
                            ), false, false))), vec<*binding<type>>()))))
    }

    var scope_lookup: fun(*tree<ast>, str, bool, *tree<ast>, str, str): OptionVecAst = fun(scope: *tree<ast>, name: str, is_type: bool, item: *tree<ast>, pass: str, pass_dep_on: str): OptionVecAst {
        /*println("doing a scope lookup for " + name + " starting from " + to_string(scope->data))*/
        var to_ret = vec<*tree<ast>>()
        for (var i = 0; i < scope->children.size; i++;) {
            match(scope->children[i]->data) {
                ast::_import(b) if b.second.contains(name) || b.second.contains(str("*")) {
                    if !ast_bound(b.first) {
                        // Import / parse file if not already
                        var file_path = ast_binding_str(b.first)
                        if (!name_ast_map.contains_key(file_path)) {
                            printerr(file_path + ", ")
                            var parse_tree = parse.parse_input(read_file(file_path), file_path)
                            trim(parse_tree)
                            name_ast_map[file_path] = syntax_to_ast(file_path, parse_tree, import_paths)
                            printlnerr("syntax_to_ast " + file_path + ":")
                            print_tree(name_ast_map[file_path], 1)
                        }
                        set_ast_binding(b.first, name_ast_map[file_path])
                    }
                    var other_top_level = get_ast_binding(b.first)
                    if item != null<tree<ast>>() {
                        if !pass_poset.done(make_pair(other_top_level, str("translation_unit_top_type_resolve"))) {
                            pass_poset.add_open_dep(make_pair(item, pass), make_pair(other_top_level, pass_dep_on))
                            return OptionVecAst::None()
                        }
                    }
                    match (scope_lookup(other_top_level, name, is_type, item, pass, pass_dep_on)) {
                        OptionVecAst::None() return OptionVecAst::None()
                        OptionVecAst::Some(v) {
                            to_ret.add_all_unique(v)
                        }
                    }
                }
                ast::_type_def(b)           if (is_type && b == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_adt_def(b)            if (is_type && b == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_function(b)           if (!is_type && b.first == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_compiler_intrinsic(b) if (!is_type && b.first == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_template(b)           if (((!is_type && is_function(scope->children[i]->children[0]))
                                              || (!is_type && is_compiler_intrinsic(scope->children[i]->children[0]))
                                              || ( is_type && is_type_def(scope->children[i]->children[0]))
                                              || ( is_type && is_adt_def( scope->children[i]->children[0]))) && b.first == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_identifier(b)         if (!is_type && b.first == name)
                                                to_ret.add_unique(scope->children[i])
                ast::_declaration()         if (!is_type && scope->children[i]->children[0]->data._identifier.first == name)
                                                to_ret.add_unique(scope->children[i]->children[0])
            }
        }
        if (scope->parent != null<tree<ast>>()) {
            match (scope_lookup(scope->parent, name, is_type, item, pass, pass_dep_on)) {
                OptionVecAst::None() return OptionVecAst::None()
                OptionVecAst::Some(v) to_ret.add_all_unique(v)
            }
        }
        else if (primitive_ops.contains_key(name))
            to_ret.add_all_unique(primitive_ops[name])
        return OptionVecAst::Some(to_ret)
    }

    passes[str("translation_unit_generative")] = fun(item: *tree<ast>) {
        println("Running translation_unit_generative")
        if !is_translation_unit(item) {
            error("Running translation_unit_generative on not a translation unit");
        }
        for (var i = 0; i < item->children.size; i++;) {
            var child = item->children[i]
            match (child->data) {
                ast::_type_def(name) {
                    println("Found a type_def! - " + name)
                    for (var j = 0; j < child->children.size; j++;) {
                        var grandchild = child->children[j];
                        if is_declaration(grandchild) {
                            var ident = grandchild->children[0]
                            var ident_name = ident->data._identifier.first
                            var ident_type = ident->data._identifier.second
                            var type_def_binding = make_ast_binding(name)
                            set_ast_binding(type_def_binding, child)
                            item->add_child(_compiler_intrinsic(ident_name, binding_p(type::_fun(make_triple(make_pair(vec(
                                        make_pair(ref_type::_notref(), binding_p(type::_obj(type_def_binding)))
                                    ),
                                make_pair(ref_type::_notref(), ident_type)
                            ), false, false))), vec<*binding<type>>()))
                            println("adding compiler intrinsic to do " + name + "." + ident_name)
                        }
                    }
                }
                ast::_template(name_map_pair) {
                    if is_type_def(child->children[0]) {
                        var name = child->children[0]->data._type_def
                        println("Found a templated type_def! - " + name)
                        for (var j = 0; j < child->children[0]->children.size; j++;) {
                            var great_grandchild = child->children[0]->children[j];
                            if is_declaration(great_grandchild) {
                                var ident = great_grandchild->children[0]
                                var ident_name = ident->data._identifier.first

                                // the map retains the order
                                var new_template_type_map = name_map_pair.second.associate(fun(n: str, t: *binding<type>): pair<str, *binding<type>> return make_pair(n, binding_p(type::_template_placeholder()));)
                                var new_ident_type = inst_temp_type(ident->data._identifier.second, name_map_pair.second.associate(fun(n: str, t: *binding<type>): pair<*binding<type>, *binding<type>>
                                                                                    return make_pair(t, new_template_type_map[n]);))

                                var type_def_binding = make_ast_binding(name, new_template_type_map.values)
                                // do we need to set the binding to the template?
                                /*set_ast_binding(type_def_binding, child)*/

                                item->add_child(_template(ident_name, new_template_type_map, vec(_compiler_intrinsic(ident_name, binding_p(type::_fun(make_triple(make_pair(vec(
                                            make_pair(ref_type::_notref(), binding_p(type::_obj(type_def_binding)))
                                        ),
                                    make_pair(ref_type::_notref(), new_ident_type)
                                ), false, false))), vec<*binding<type>>()))))
                                println("adding compiler intrinsic to do " + name + "." + ident_name)
                            }
                        }
                    }
                }
            }
        }

        println("post generative")
        print_tree(item, 1)
    }

    var binding_types = map<*tree<ast>, *binding<type>>()
    var get_type: fun(*tree<ast>): *binding<type> = fun(a: *tree<ast>): *binding<type> {
        var get_template_type: fun(*tree<ast>, vec<*binding<type>>): *binding<type> = fun(a: *tree<ast>, inst_with: vec<*binding<type>>): *binding<type> {
            var i = 0
            return inst_temp_type(get_type(a->children[0]), a->data._template.second.associate(fun(k: str, v: *binding<type>): pair<*binding<type>, *binding<type>> {
                if (i < inst_with.size)
                    return make_pair(v, inst_with[i])
                else
                    return make_pair(v, binding_p(type::_unknown()))
            }))
        }
        match(a->data) {
            ast::_identifier(b)         return b.second
            ast::_binding(b)            if (binding_types.contains_key(a)) {
                                            if ast_bound(a) && has_unknown(binding_types[a]) {
                                                var t = null<binding<type>>()
                                                var bound_to = get_ast_binding(a)
                                                if (is_template(bound_to)) {
                                                    t = get_template_type(bound_to, b.second)
                                                    unify(binding_types[a], t)
                                                } else {
                                                    t = get_type(bound_to)
                                                    unify(binding_types[a], t)
                                                }
                                            }
                                            return binding_types[a]
                                        } else {
                                            if (ast_bound(a)) {
                                                var t = null<binding<type>>()
                                                var bound_to = get_ast_binding(a)
                                                if (is_template(bound_to)) {
                                                    t = get_template_type(bound_to, b.second)
                                                } else {
                                                    t = get_type(bound_to)
                                                }
                                                binding_types[a] = t
                                                return t
                                            } else {
                                                var new_type = binding_p(type::_unknown())
                                                binding_types[a] = new_type
                                                return new_type
                                            }
                                        }
            ast::_function(b)           return b.second
            ast::_template(b)           return get_template_type(a, vec<*binding<type>>())
            ast::_compiler_intrinsic(b) return b.second
            ast::_call(add_scope) {
                var t = get_type(a->children[0])
                if (is_fun(t->bound_to))
                    return t->bound_to->_fun.first.second.second
                if (is_unknown(t->bound_to)) {
                    var return_type = make_pair(ref_type::_unknown(), binding_p(type::_unknown()))
                    var parameter_types = vec<pair<ref_type, *binding<type>>>()
                    for (var i = 1; i < a->children.size; i++;)
                        parameter_types.add(make_pair(ref_type::_unknown(), get_type(a->children[i])))
                    t->set(type::_fun(make_triple(make_pair(parameter_types, return_type), false, false)))
                    return return_type.second
                }
                error("Trying to get type of call where type of first child is not function, but " + to_string(t->bound_to))
            }
            ast::_cast(b)               return b
            ast::_value(b)              return b.second
        }
        error("Trying to get type of node without one: " + to_string(a->data))
    }

    passes[str("translation_unit_top_type_resolve")] = fun(item: *tree<ast>) {
        println("Running translation_unit_top_type_resolve")
        if !is_translation_unit(item) {
            error("Running translation_unit_top_type_resolve on not a translation unit");
        }
        if !pass_poset.done(make_pair(item, str("translation_unit_generative"))) {
            pass_poset.add_open_dep(make_pair(item, str("translation_unit_top_type_resolve")), make_pair(item, str("translation_unit_generative")))
            return
        }
        var quick_bind = fun(binding: *tree<ast>, start_scope: *tree<ast>, additional_scope: *tree<ast>, type_binding: bool): bool {
            if !ast_bound(binding) {
                match (scope_lookup(start_scope, ast_binding_str(binding), type_binding, item, str("translation_unit_top_type_resolve"), str("translation_unit_generative"))) {
                    OptionVecAst::None() {
                        return false;
                    }
                    OptionVecAst::Some(options) {
                        if (options.size < 1) {
                            error("couldn't find any possibilities for " + ast_binding_str(binding))
                        }
                        println(ast_binding_str(binding) + " resolving at top level to " + to_string(options[0]->data))
                        set_ast_binding(binding, options[0])
                    }
                }
            }
            return true;
        }
        var quick_bind_type: fun(*binding<type>, *tree<ast>): bool = fun(t: *binding<type>, n: *tree<ast>): bool {
            match(*t->bound_to) {
                type::_obj(b) return quick_bind(b, n, null<tree<ast>>(), true)
                type::_ptr(p) return quick_bind_type(p, n)
                type::_fun(b) {
                    for (var i = 0; i < b.first.first.size; i++;)
                        if (!quick_bind_type(b.first.first[i].second, n))
                            return false
                    return quick_bind_type(b.first.second.second, n)
                }
            }
            return true
        }
        for (var i = 0; i < item->children.size; i++;) {
            var child = item->children[i]
            match (child->data) {
                ast::_template(name_map_pair) {
                    if is_function(child->children[0]) {
                        quick_bind_type(get_type(child->children[0]), item)
                    }
                }
                ast::_declaration() {
                    quick_bind_type(get_type(child->children[0]), item)
                }
                ast::_function(name_type_ext) {
                    quick_bind_type(get_type(child), item)
                }
                ast::_compiler_intrinsic(name_type_ext) {
                    quick_bind_type(get_type(child), item)
                }
            }
        }

        println("post translation_unit_top_type_resolve")
        print_tree(item, 1)
    }

    // resolves all binding possibilities to a single one for one top level item
    passes[str("name_type_resolve")] = fun(item: *tree<ast>) {
        println("name_type resolve for:")
        print_tree(item, 1)

        var try_to_find_binding_possibilities = fun(binding: *tree<ast>, start_scope: *tree<ast>, additional_scope: *tree<ast>, type_binding: bool): bool {
            if !ast_bound(binding) && !multiple_binding_options.contains_key(binding) {
                var all_options = vec<*tree<ast>>()
                match (scope_lookup(start_scope, ast_binding_str(binding), type_binding, item, str("name_type_resolve"), str("translation_unit_top_type_resolve"))) {
                    OptionVecAst::None() {
                        println("OptionVecAst::None for " + ast_binding_str(binding) + " lookup, returning")
                        return false;
                    }
                    OptionVecAst::Some(options) {
                        println("OptionVecAst::Some for " + ast_binding_str(binding) + " lookup, continuing!")
                        all_options += options
                    }
                }
                if additional_scope != null<tree<ast>>() {
                    println("Additionally looking at scope " + to_string(additional_scope->data) + " for try_to_find_binding_possibilities " + ast_binding_str(binding))
                    match (scope_lookup(additional_scope, ast_binding_str(binding), type_binding, item, str("name_type_resolve"), str("translation_unit_top_type_resolve"))) {
                        OptionVecAst::None() {
                            println("OptionVecAst::None for " + ast_binding_str(binding) + " lookup, returning")
                            return false;
                        }
                        OptionVecAst::Some(options) {
                            println("OptionVecAst::Some for " + ast_binding_str(binding) + " lookup, continuing!")
                            all_options.add_all_unique(options)
                        }
                    }
                }
                if (all_options.size == 0) {
                    error("Could not find any options for scope lookup of " + ast_binding_str(binding))
                } else if (all_options.size == 1) {
                    println(ast_binding_str(binding) + " resolved to a single!")
                    set_ast_binding(binding, all_options[0])
                } else {
                    println(ast_binding_str(binding) + " found to have " + all_options.size + " options!")
                    for (var i = 0; i < all_options.size; i++;)
                        println("\t" + to_string(all_options[i]->data))
                    multiple_binding_options[binding] = all_options
                }
            }
            return true;
        }
        var handle_type_binding_possibilities: fun(*binding<type>, *tree<ast>): bool = fun(t: *binding<type>, n: *tree<ast>): bool {
            match(*t->bound_to) {
                type::_obj(b) return try_to_find_binding_possibilities(b, n, null<tree<ast>>(), true)
                type::_ptr(p) return handle_type_binding_possibilities(p, n)
                type::_fun(b) {
                    for (var i = 0; i < b.first.first.size; i++;)
                        if (!handle_type_binding_possibilities(b.first.first[i].second, n))
                            return false
                    return handle_type_binding_possibilities(b.first.second.second, n)
                }
            }
            return true
        }

        var traverse_for_unify: fun(*tree<ast>): void = fun(t: *tree<ast>) {
            t->children.for_each(traverse_for_unify)
            match (t->data) {
                // even if we have nothing to unify it with, we call get_type on all bindings so that it gets put in the binding map
                ast::_binding(b) get_type(t)
                ast::_declaration() if (t->children.size > 1)
                                        unify(get_type(t->children[0]), get_type(t->children[1]))
                ast::_call(add_scope) {
                    println("traverse_for_unify call - " + to_string(t->data))
                    // we call get type to make sure if it is unknown it is transformed into a function version
                    get_type(t)
                    println("\tpast first get_type")
                    var fun_type = get_type(t->children[0])->bound_to
                    println("\tpast second get_type")
                    if (!is_fun(fun_type))
                        error("trying to call not a function type: " + to_string(fun_type))
                    if (fun_type->_fun.first.first.size != (t->children.size - 1))
                        error("trying to call function with type wrong number of params (" + to_string(fun_type->_fun.first.first.size) + " vs " + to_string(t->children.size - 1) + "): " + to_string(fun_type))
                    println("\titerating through children, matching their type with the param type")
                    for (var i = 1; i < t->children.size; i++;)
                        unify(fun_type->_fun.first.first[i-1].second, get_type(t->children[i]))
                }
                ast::_return() if (t->children.size > 0)
                                   unify(get_type(get_ancestor_satisfying(t, fun(t: *tree<ast>): bool return is_function(t);))->bound_to->_fun.first.second.second, get_type(t->children[0]))
            }
        }
        traverse_for_unify(item)

        var more_to_do = true
        while (more_to_do) {
            println("RESOLVE LOOP BEGIN")
            more_to_do = false
            var work_done = false
            var traverse_for_select: fun(*tree<ast>): bool = fun(t: *tree<ast>): bool {
                var children_start_index = 0
                match (t->data) {
                    ast::_identifier(b)         if (!handle_type_binding_possibilities(b.second, t))
                                                    return false;
                    /*_binding: triple<str, vec<*type>, *tree<ast>>,*/
                    ast::_function(b)           if (!handle_type_binding_possibilities(b.second, t))
                                                    return false;
                    ast::_compiler_intrinsic(b) {
                        if (!handle_type_binding_possibilities(b.second, t))
                            return false;
                        for (var i = 0; i < b.third.size; i++;)
                            if (!handle_type_binding_possibilities(b.third[i], t))
                                return false;
                        /*b.third.for_each(fun(tb: *binding<type>) {*/
                            /*handle_type_binding_possibilities(tb, t)*/
                        /*})*/
                    }
                    ast::_cast(b)               if (!handle_type_binding_possibilities(b, t))
                                                    return false;
                    ast::_call(add_scope) {
                        println("call of " + to_string(t->children[0]) + ", that is " + to_string(t->children[0]->data) + " has type " + to_string(get_type(t)->bound_to) + ", and the function has type " + to_string(get_type(t->children[0])->bound_to))
                        /*get_type(t)*/
                        if add_scope && is_binding(t->children[0]) && !ast_bound(t->children[0]) && !multiple_binding_options.contains_key(t->children[0]) {
                            var first_param_type = get_type(t->children[1])
                            if !is_unknown(first_param_type->bound_to) && (!is_obj(first_param_type->bound_to) || ast_bound(first_param_type->bound_to->_obj)) {
                                if is_obj(first_param_type->bound_to) {
                                    if (!try_to_find_binding_possibilities(t->children[0], t->children[0], get_ast_binding(first_param_type->bound_to->_obj)->parent, false))
                                        return false;
                                } else {
                                    if (!try_to_find_binding_possibilities(t->children[0], t->children[0], null<tree<ast>>(), false))
                                        return false
                                }
                                work_done = true
                                println("wok done! generic add posibilities (or down to one) for " + to_string(t->children[0]->data))
                                if ast_bound(t->children[0]) {
                                    unify(binding_types[t->children[0]], get_type(get_ast_binding(t->children[0])))
                                }
                            } else {
                                children_start_index = 1
                                more_to_do = true
                            }
                        }
                    }

                    ast::_binding(b) if (!ast_bound(t)) {
                        println(to_string(t->data) + " - not bound!")
                        if !multiple_binding_options.contains_key(t) {
                            if (!try_to_find_binding_possibilities(t, t, null<tree<ast>>(), false))
                                return false
                        }
                        if ast_bound(t) {
                            unify(binding_types[t], get_type(get_ast_binding(t)))
                            work_done = true
                            println("wok done! set " + to_string(t->data))
                        } else {
                            // isn't function, by shadowing we just take the first
                            if !is_fun(binding_types[t]->bound_to) {
                                if (!multiple_binding_options[t].size > 0)
                                    error("No possible options for " + to_string(t->data))
                                var it = multiple_binding_options[t][0]
                                set_ast_binding(t, it)
                                unify(binding_types[t], get_type(it))
                                work_done = true
                            } else {
                                // function type, so we have to get interesting
                                var filtered_options = multiple_binding_options[t].filter(fun(p: *tree<ast>): bool return equality(binding_types[t]->bound_to, get_type(p)->bound_to, true);)
                                if (filtered_options.size == 0) {
                                    println("Attempting to use our inferenced type " + to_string(binding_types[t]->bound_to) + " to decide what to bind " + to_string(t->data) + " to from options:")
                                    multiple_binding_options[t].for_each(fun(p: *tree<ast>) { println("\t" + to_string(p->data) + " of type " + to_string(get_type(p)->bound_to)); })
                                    error("no options remain after filtering overloads by type for " + to_string(t->data))
                                } else if (filtered_options.size > 1) {
                                    println("inferenced type " + to_string(binding_types[t]->bound_to) + " HAD MULTIPLE OPTIONS AFTER FILTER for "  + to_string(t) + ", that is "+ to_string(t->data))
                                    more_to_do = true
                                } else {
                                    set_ast_binding(t, filtered_options[0])
                                    unify(binding_types[t], get_type(filtered_options[0]))
                                    work_done = true
                                    println("wok done! set " + to_string(t->data))
                                }
                            }
                        }
                    }
                }
                for (var i = children_start_index; i < t->children.size; i++;) {
                    if !traverse_for_select(t->children[i]) {
                        return false
                    }
                }
                return true
            }
            // early bail if we need more passes
            if !traverse_for_select(item) {
                println("bailing early b/c select")
                return
            }
            if (!work_done) {
                var traverse_for_error: fun(*tree<ast>): void = fun(t: *tree<ast>) {
                    match (t->data) {
                        ast::_binding(b) if (!ast_bound(t)) {
                            println("Trying to error out because we made no progress")
                            var filtered_options = multiple_binding_options[t].filter(fun(p: *tree<ast>): bool return equality(binding_types[t]->bound_to, get_type(p)->bound_to, true);)
                            if (filtered_options.size > 1) {
                                println("Attempting to use our inferenced type " + to_string(binding_types[t]->bound_to) + " to decide what to bind " + to_string(t->data) + " to form options:")
                                multiple_binding_options[t].for_each(fun(p: *tree<ast>) { println("\t" + to_string(p->data) + " of type " + to_string(get_type(p)->bound_to)); })
                                println("current state of this:")
                                print_tree(item, 1)
                                println("too many options remain after filtering overloads by type for " + to_string(t->data) + ", they were:")
                                filtered_options.for_each(fun(p: *tree<ast>) { println("\t" + to_string(p->data) + " of type " + to_string(get_type(p)->bound_to)); })
                                error("cannot resolve")
                            }
                        }
                    }
                    t->children.for_each(traverse_for_error)
                }
                traverse_for_error(item)
            }
        }
        println("tree after pass (might have added a dependency though)")
        print_tree(item, 1)
    }


    var taken_names = map<*tree<ast>, str>()
    var id = 0

    var replacement_map.construct() : map<str, str>
    replacement_map[str("+")] = str("plus")
    replacement_map[str("-")] = str("minus")
    replacement_map[str("*")] = str("star")
    replacement_map[str("/")] = str("div")
    replacement_map[str("%")] = str("mod")
    replacement_map[str("^")] = str("carat")
    replacement_map[str("&")] = str("amprsd")
    replacement_map[str("|")] = str("pipe")
    replacement_map[str("~")] = str("tilde")
    replacement_map[str("!")] = str("exlmtnpt")
    replacement_map[str(",")] = str("comma")
    replacement_map[str("=")] = str("eq")
    replacement_map[str("++")] = str("dbplus")
    replacement_map[str("--")] = str("dbminus")
    replacement_map[str("<<")] = str("dbleft")
    replacement_map[str(">>")] = str("dbright")
    replacement_map[str("::")] = str("scopeop")
    replacement_map[str(":")] = str("colon")
    replacement_map[str("==")] = str("dbq")
    replacement_map[str("!=")] = str("notequals")
    replacement_map[str("&&")] = str("doubleamprsnd")
    replacement_map[str("||")] = str("doublepipe")
    replacement_map[str("+=")] = str("plusequals")
    replacement_map[str("-=")] = str("minusequals")
    replacement_map[str("/=")] = str("divequals")
    replacement_map[str("%=")] = str("modequals")
    replacement_map[str("^=")] = str("caratequals")
    replacement_map[str("&=")] = str("amprsdequals")
    replacement_map[str("|=")] = str("pipeequals")
    replacement_map[str("*=")] = str("starequals")
    replacement_map[str("<<=")] = str("doublerightequals")
    replacement_map[str("<")] = str("lt")
    replacement_map[str(">")] = str("gt")
    replacement_map[str(">>=")] = str("doubleleftequals")
    replacement_map[str("(")] = str("openparen")
    replacement_map[str(")")] = str("closeparen")
    replacement_map[str("[")] = str("obk")
    replacement_map[str("]")] = str("cbk")
    replacement_map[str(" ")] = str("_")
    replacement_map[str(".")] = str("dot")
    replacement_map[str("->")] = str("arrow")

    var longest_replacement = 0
    replacement_map.for_each(fun(key: str, value: str) {
        if (key.length() > longest_replacement)
            longest_replacement = key.length()
    })
    var cify_name = fun(name: ref str): str {
        var to_ret = str()
        for (var i = 0; i < name.length(); i++;) {
            var replaced = false
            for (var j = longest_replacement; j > 0; j--;) {
                if (i + j <= name.length() && replacement_map.contains_key(name.slice(i,i+j))) {
                   to_ret += replacement_map[name.slice(i,i+j)]
                   replaced = true
                   i += j-1;
                   break
                }
            }
            if (!replaced)
               to_ret += name[i]
        }
        return to_ret
    }
    var get_c_name = fun(x: *tree<ast>): str {
        if (taken_names.contains_key(x))
            return taken_names[x]
        var possible = str()
        match(x->data) {
            /*ast::_identifier(b) { possible = b.first; }*/
            ast::_identifier(b) { return b.first; }
            ast::_type_def(b)   { possible = b; }
            ast::_function(b)   { possible = b.first; }
        }
        if (possible == "")
            error("cannot get_c_name of thing: " + to_string(x->data))
        if (taken_names.contains_value(possible)) {
            possible += id++
        }
        taken_names[x] = cify_name(possible)
        return taken_names[x]
    }

    var to_c_type: fun(*binding<type>): str = fun(tb: *binding<type>): str {
        match(*tb->bound_to) {
            type::_unknown()              error("unknown in to_c_type")
            /*type::_unknown()              return str("unknown")*/
            type::_ptr(p)                 return to_c_type(p) + "*"
            type::_void()                 return str("void")
            type::_obj(b)                 return get_c_name(get_ast_binding(b))
            type::_fun(b)                 error("fun in to_c_type unimplemented")
            type::_template_placeholder() error("template_placeholder in to_c_type")
            type::_bool()                 return str("bool")
            type::_char()                 return str("char")
            type::_uchar()                return str("usigned char")
            type::_short()                return str("short")
            type::_ushort()               return str("unsigned short")
            type::_int()                  return str("int")
            type::_uint()                 return str("unsigned int")
            type::_long()                 return str("long")
            type::_ulong()                return str("unsigned long")
            type::_float()                return str("float")
            type::_double()               return str("double")
        }
        error("fell through to_c_type")
    }

    passes[str("ref_lower")] = fun(item: *tree<ast>) {
        println("Running ref_lower")
        if !pass_poset.done(make_pair(item, str("name_type_resolve"))) {
            pass_poset.add_open_dep(make_pair(item, str("ref_lower")), make_pair(item, str("name_type_resolve")))
            return
        }
        var parameter_update_map = map<*tree<ast>, *tree<ast>>()
        var traverse_for_ref: fun(*tree<ast>): void = fun(t: *tree<ast>) {
            match (t->data) {
                ast::_function(name_type_ext) {
                    var fun_type = get_type(t)
                    for (var i = 0; i < fun_type->bound_to->_fun.first.first.size; i++;) {
                        if fun_type->bound_to->_fun.first.first[i].first == ref_type::_ref() {
                            var old_param = t->children[i]
                            println("function definition has refs - " + old_param->data._identifier.first)
                            var new_param = _identifier(old_param->data._identifier.first, binding_p(type::_ptr(old_param->data._identifier.second)))
                            parameter_update_map[old_param] = new_param
                            t->set_child(i, new_param)
                        }
                    }
                }
                ast::_call(add_scope) {
                    println("traverse_for_ref call - " + to_string(t->data))
                    // we call get type to make sure if it is unknown it is transformed into a function version
                    var fun_type = get_type(t->children[0])->bound_to
                    println("\t checking " + to_string(t->children[0]->data) + " for reffed params: " + to_string(fun_type))
                    for (var i = 1; i < t->children.size; i++;) {
                        if fun_type->_fun.first.first[i-1].first == ref_type::_ref() {
                            println(str("\t\tparam ") + i + " is reffed")
                            var addr_of_binding = make_ast_binding("op&")
                            set_single_ast_binding(addr_of_binding, primitive_ops[str("op&")].last())
                            unify(get_type(addr_of_binding)->bound_to->_fun.first.first[0].second, get_type(t->children[i]))
                            t->set_child(i, _call(false, vec(addr_of_binding, t->children[i])))
                        }
                    }
                    if fun_type->_fun.first.second.first == ref_type::_ref() {
                        println("call's return is reffed!")
                        var addr_of_binding = make_ast_binding("op*")
                        set_single_ast_binding(addr_of_binding, primitive_ops[str("op*")].last())
                        unify(get_type(addr_of_binding)->bound_to->_fun.first.first[0].second, binding_p(type::_ptr(fun_type->_fun.first.second.second)))
                        // BUG IN kraken compiler, or weird part of kraken itself - evaluation order isn't guarenteed, so evaling a param could change lhs
                        /*t->parent->replace_child(t, _call(false, vec(addr_of_binding, t)))*/
                        var parent = t->parent
                        parent->replace_child(t, _call(false, vec(addr_of_binding, t)))
                    }
                }
                ast::_binding(b) {
                    var bound_to = get_ast_binding(t)
                    if parameter_update_map.contains_key(bound_to) {
                        println("param binding is reffed")
                        var new_param = parameter_update_map[bound_to]
                        var addr_of_binding = make_ast_binding("op*")
                        set_single_ast_binding(addr_of_binding, primitive_ops[str("op*")].last())
                        unify(get_type(addr_of_binding)->bound_to->_fun.first.first[0].second, get_type(new_param))
                        t->parent->replace_child(t, _call(false, vec(addr_of_binding, new_param)))
                    }
                }
                ast::_return() {
                    if (t->children.size > 0) {
                        var ret_is_ref = get_type(get_ancestor_satisfying(t, fun(t: *tree<ast>): bool return is_function(t);))->bound_to->_fun.first.second.first == ref_type::_ref()
                        if ret_is_ref {
                            println("return is reffed")
                            var addr_of_binding = make_ast_binding("op&")
                            set_single_ast_binding(addr_of_binding, primitive_ops[str("op&")].last())
                            unify(get_type(addr_of_binding)->bound_to->_fun.first.first[0].second, get_type(t->children[0]))
                            t->set_child(0, _call(false, vec(addr_of_binding, t->children[0])))
                        }
                    }
                }
            }
            t->children.for_each(traverse_for_ref)
        }
        traverse_for_ref(item)

        println("post ref_lower")
        print_tree(item, 1)
    }

    // has to be set<pair> instead of map<> as we need to use type's "equality"
    // function instead of type's adt's operator==
    var instantiated_map = map<*tree<ast>, set<pair<*binding<type>, *tree<ast>>>>()
    passes[str("depend_and_template_resolve")] = fun(item: *tree<ast>) {
        if !pass_poset.done(make_pair(item, str("ref_lower"))) {
            pass_poset.add_open_dep(make_pair(item, str("depend_and_template_resolve")), make_pair(item, str("ref_lower")))
            return
        }

        println("what we've got at template resolve time")
        print_tree(item, 1)

        var resolve: fun(*tree<ast>): void = fun(t: *tree<ast>) {
            var resolve_type: fun(*binding<type>): void = fun(t: *binding<type>) {
                match (*t->bound_to) {
                    type::_unknown() error("unknown in resolve_type")
                    type::_template_placeholder() error("template_placeholder in resolve_type")
                    type::_ptr(p) resolve_type(p)
                    type::_obj(o) {
                        resolve(o)
                        pass_poset.add_close_dep(make_pair(item, str("emit_C")), make_pair(get_ast_binding(o), str("emit_C")))
                    }
                    type::_fun(t) {
                        t.first.first.for_each(fun(p: pair<ref_type, *binding<type>>): void { resolve_type(p.second); })
                        resolve_type(t.first.second.second)
                    }
                }
            }
            match (t->data) {
                ast::_binding(b) {
                    var bound_to = get_ast_binding(t)
                    if (is_top_level_item(bound_to)) {
                        if (is_template(bound_to)) {
                            if (!instantiated_map.contains_key(bound_to)) {
                                instantiated_map[bound_to] = set<pair<*binding<type>, *tree<ast>>>()
                            }

                            // grab inst types out of binding, or regen again from unify? Cache from first unify?
                            var inst_map = map<*binding<type>, *binding<type>>()
                            if (b.second.size > 0) {
                                for (var i = 0; i < b.second.size; i++;) {
                                    inst_map[bound_to->data._template.second.values[i]] = b.second[i]
                                }
                            } else {
                                // regenning from unify
                                inst_map = bound_to->data._template.second.associate(fun(k: str, v: *binding<type>): pair<*binding<type>, *binding<type>>
                                                                                            return make_pair(v, binding_p(type::_unknown()));)
                            }

                            // but not in the case where this is a templated type instead of a function - that doesn't make any sense
                            var binding_type = null<binding<type>>()
                            if is_function(bound_to->children[0]) || is_compiler_intrinsic(bound_to->children[0]) {
                                // unify in both cases - we need it in the explicit case to make sure our explicit types propegate back
                                binding_type = get_type(t)
                                unify(binding_type, inst_temp_type(get_type(bound_to->children[0]), inst_map))
                            } else {
                                binding_type = binding_p(type::_obj(t))
                            }

                            // shouldn't cache by binding, but by all insted
                            println("checking for prior instantiations of " + to_string(bound_to->data))
                            var already_inst = instantiated_map[bound_to].filter(fun(p: pair<*binding<type>, *tree<ast>>): bool return equality(binding_type->bound_to, p.first->bound_to, false);)
                            if (already_inst.size() > 1) {
                                error("already inst > 1, should be impossible")
                            } else if (already_inst.size() == 1) {
                                println("alreay instantiated template, using (made from):")
                                print_tree(bound_to->children[0], 1)
                                println("cached to:")
                                print_tree(already_inst.single().second, 1)
                                pass_poset.add_close_dep(make_pair(item, str("emit_C")), make_pair(already_inst.single().second, str("emit_C")))
                                set_single_ast_binding(t, already_inst.single().second)
                            } else {
                                println("Copying tree to instantiate template!" + to_string(bound_to->data))
                                println("using inst map:")
                                inst_map.for_each(fun(k: *binding<type>, v: *binding<type>) {
                                    println("\t" + to_string(k->bound_to) + " -> " + to_string(v->bound_to))
                                })
                                var inst_copy = bound_to->children[0]->clone(fun(a: ref ast): ast {
                                    match (a) {
                                        ast::_identifier(b)         return ast::_identifier(make_pair(b.first, inst_temp_type(b.second, inst_map)))
                                        ast::_binding(b)            return ast::_binding(make_triple(b.first,
                                                                                                     b.second.map(fun(bd: *binding<type>): *binding<type> return inst_temp_type(bd, inst_map);),
                                                                                                     binding<tree<ast>>()))
                                        ast::_function(b)           return ast::_function(make_triple(b.first, inst_temp_type(b.second, inst_map), b.third))
                                        ast::_compiler_intrinsic(b) return ast::_compiler_intrinsic(make_triple(
                                                                                                            b.first,
                                                                                                            inst_temp_type(b.second, inst_map),
                                                                                                            b.third.map(fun(bd: *binding<type>): *binding<type> return inst_temp_type(bd, inst_map);)))
                                        ast::_cast(b)               return ast::ast::_cast(inst_temp_type(b, inst_map))
                                        ast::_value(b)              return ast::_value(make_pair(b.first, inst_temp_type(b.second, inst_map)))
                                        /*_template: pair<str, map<str, *binding<type>>>,*/
                                    }
                                    return a
                                })
                                // add inst copy as a child of template?
                                bound_to->add_child(inst_copy)

                                println("inst from:")
                                print_tree(bound_to->children[0], 1)
                                println("inst to:")
                                print_tree(inst_copy, 1)

                                // save it in our insted map so we don't instantate more than once per types
                                if is_function(bound_to->children[0]) || is_compiler_intrinsic(bound_to->children[0]) {
                                    var binding_type2 = get_type(clone_ast_binding(t))
                                    unify(binding_type2, inst_temp_type(get_type(bound_to->children[0]), inst_map))
                                    instantiated_map[bound_to].add(make_pair(binding_type2, inst_copy))
                                } else {
                                    instantiated_map[bound_to].add(make_pair(binding_p(type::_obj(clone_ast_binding(t))), inst_copy))
                                }
                                pass_poset.add_close_dep(make_pair(item, str("emit_C")), make_pair(inst_copy, str("emit_C")))
                                set_single_ast_binding(t, inst_copy)
                            }
                        } else {
                            pass_poset.add_close_dep(make_pair(item, str("emit_C")), make_pair(bound_to, str("emit_C")))
                        }
                    // top level var dec
                    } else if (is_identifier(bound_to) && is_declaration(bound_to->parent) && is_top_level_item(bound_to->parent)) {
                        pass_poset.add_close_dep(make_pair(item, str("emit_C")), make_pair(bound_to->parent, str("emit_C")))
                    }
                    // bound_to might have changed from binding
                }
                ast::_identifier(p) resolve_type(get_type(t))
                ast::_function(p) resolve_type(get_type(t))
                ast::_compiler_intrinsic(p) {
                    resolve_type(p.second)
                    p.third.for_each(resolve_type)
                }
                ast::_cast(p) resolve_type(p)
            }


            t->children.for_each(resolve)
        }
        resolve(item)
    }

    passes[str("defer_lower")] = fun(item: *tree<ast>) {
        if !pass_poset.done(make_pair(item, str("depend_and_template_resolve"))) {
            pass_poset.add_open_dep(make_pair(item, str("defer_lower")), make_pair(item, str("depend_and_template_resolve")))
            return
        }
        var defer_triple_stack = stack<stack<stack<*tree<ast>>>>()
        var loop_stack = stack(-1)
        var traverse_for_defer: fun(*tree<ast>): void = fun(t: *tree<ast>) {
            match (t->data) {
                ast::_defer() {
                    if (is_block(t->parent)) {
                        t->parent->remove_child(t)
                        defer_triple_stack.top().top().push(t->children[0])
                    } else {
                        t->parent->replace_child(t, t->children[0])
                    }
                    traverse_for_defer(t->children[0])
                    return;
                }
                ast::_function(name_type_ext) {
                    defer_triple_stack.push(stack<stack<*tree<ast>>>())
                    t->children.clone().for_each(traverse_for_defer)
                    defer_triple_stack.pop()
                    return;
                }
                ast::_block() {
                    defer_triple_stack.top().push(stack<*tree<ast>>())
                    t->children.clone().for_each(traverse_for_defer)
                    t->children.add_all(defer_triple_stack.top().pop().reverse_vector())
                    return;
                }
                ast::_for() {
                    loop_stack.push(defer_triple_stack.top().size())
                    t->children.clone().for_each(traverse_for_defer)
                    loop_stack.pop()
                    return;
                }
                ast::_while() {
                    loop_stack.push(defer_triple_stack.top().size())
                    t->children.clone().for_each(traverse_for_defer)
                    loop_stack.pop()
                    return;
                }
                ast::_return() {
                    t->children.clone().for_each(traverse_for_defer)
                    var our_idx = t->parent->children.find(t)
                    for (var i = 0; i < defer_triple_stack.top().size(); i++;) {
                        defer_triple_stack.top().from_top(i).reverse_vector().for_each(fun(c: *tree<ast>) {
                            t->parent->children.add(our_idx, c)
                        })
                    }
                    return;
                }
                ast::_break() {
                    var block = _block()
                    t->parent->replace_child(t, block)
                    for (var i = 0; i < defer_triple_stack.top().size() - loop_stack.top(); i++;)
                        block->add_children(defer_triple_stack.top().from_top(i).reverse_vector())
                    block->add_child(t)
                    return;
                }
                ast::_continue() {
                    return;
                }
            }
            t->children.clone().for_each(traverse_for_defer)
        }
        traverse_for_defer(item)

        println("post defer_lower")
        print_tree(item, 1)
    }

    //  emit C
    var C_str = str()
    var C_type_forward_declaration_str = str()
    var C_type_declaration_str_map = map<*tree<ast>, str>()
    var C_type_declaration_poset = poset<*tree<ast>>()
    var C_declaration_str = str()

    passes[str("emit_C")] = fun(item: *tree<ast>) {
        if !pass_poset.done(make_pair(item, str("defer_lower"))) {
            pass_poset.add_open_dep(make_pair(item, str("emit_C")), make_pair(item, str("defer_lower")))
            return
        }
        println("Emitting C for:")
        print_tree(item, 1)

        var emit_C: fun(*tree<ast>, int): void = fun(t: *tree<ast>, level: int) {
            var idt = str("\t") * level
            match (t->data) {
                ast::_translation_unit(b) {
                    t->children.for_each(fun(c: *tree<ast>) {
                        emit_C(c, 0)
                        C_str += ";\n"
                    })
                }
                ast::_import(b) { }
                ast::_identifier(b)         { C_str += idt + get_c_name(t); }
                ast::_binding(b)            {
                    C_str += idt + get_c_name(get_ast_binding(t))
                }
                ast::_type_def(b) {
                    C_type_forward_declaration_str += "typedef struct " + get_c_name(t) + " " + get_c_name(t) + ";\n"
                    C_type_declaration_str_map[t] = "struct " + get_c_name(t) + "{\n"
                    C_type_declaration_poset.add_job(t)
                    t->children.for_each(fun(c: *tree<ast>) {
                        C_type_declaration_str_map[t] += "\t" + to_c_type(c->children[0]->data._identifier.second) + " " + get_c_name(c->children[0]) + ";\n"
                        if is_obj(c->children[0]->data._identifier.second->bound_to) {
                            C_type_declaration_poset.add_open_dep(t, get_ast_binding(c->children[0]->data._identifier.second->bound_to->_obj))
                        }
                    })
                    C_type_declaration_str_map[t] += "};\n"
                }
                ast::_adt_def(b)            { error("no adt_def should remain at C emit"); }
                ast::_function(b)           {
                    /*var fun_name = b.first*/
                    var fun_name = get_c_name(t)
                    var fun_type = b.second->bound_to
                    var is_ext   = b.third
                    var return_type     = fun_type->_fun.first.second
                    var parameter_types = fun_type->_fun.first.first
                    var is_variadic     = fun_type->_fun.second
                    var is_raw          = fun_type->_fun.third
                    var is_just_dec     = parameter_types.size == t->children.size
                    // TODO check is_ext for name mangling
                    // TODO ideally, we wouldn't worry about refs here, but until we have
                    //      per pass trees / bindings and stuff, we can't change the functions
                    //      type to remove ref and add ptr (though we do change the parameters type,
                    //      as that all happens inside the function)
                    var beginning_str = to_c_type(return_type.second)
                    if (return_type.first == ref_type::_ref())
                        beginning_str += "*"
                    beginning_str +=  " " + fun_name + "("
                    if (!is_just_dec)
                        C_str += beginning_str
                    C_declaration_str += beginning_str
                    for (var i = 0; i < parameter_types.size; i++;) {
                        if (i != 0) {
                            if (!is_just_dec)
                                C_str += ", "
                            C_declaration_str += ", "
                        }
                        // TODO ditto about ref stuff above
                        var parameter_type_str = to_c_type(parameter_types[i].second)
                        if (parameter_types[i].first == ref_type::_ref())
                            parameter_type_str += "*"
                        if (!is_just_dec)
                            C_str         += parameter_type_str + " "
                        C_declaration_str += parameter_type_str
                        if (!is_just_dec)
                            emit_C(t->children[i], 0)
                    }
                    if (is_variadic) {
                        if (parameter_types.size != 0) {
                            if (!is_just_dec)
                                C_str += ", "
                            C_declaration_str += ", "
                        }
                        if (!is_just_dec)
                            C_str += "..."
                        C_declaration_str += "..."
                    }
                    if (!is_just_dec)
                        C_str += ") {\n"
                    C_declaration_str += ");\n"
                    if !is_just_dec {
                        for (var i = parameter_types.size; i < t->children.size; i++;) {
                            emit_C(t->children[i], level+1)
                            C_str += ";\n"
                        }
                        C_str += "}\n"
                    }
                }
                ast::_template(b)           { /* template should be ignored */ }
                ast::_declaration()         {
                    C_str += idt + to_c_type(t->children[0]->data._identifier.second) + " " + get_c_name(t->children[0])
                    if (t->children.size > 1) {
                        C_str += " = "
                        emit_C(t->children[1], 0)
                    }
                    if (is_top_level_item(t)) {
                        C_str += ";\n"
                        C_declaration_str += idt + to_c_type(t->children[0]->data._identifier.second) + " " + get_c_name(t->children[0]) + ";\n"
                    }
                }
                ast::_block() {
                    C_str += idt + "{\n"
                    t->children.for_each(fun(c: *tree<ast>) {
                        emit_C(c, level+1)
                        C_str += ";\n"
                    })
                    C_str += idt + "}"
                }
                ast::_if()                  {
                    C_str += idt + "if ("
                    emit_C(t->children[0], 0)
                    C_str += ") {\n"
                    emit_C(t->children[1], level + 1)
                    C_str += ";\n" + idt + "}"
                    if t->children.size > 2 {
                        C_str += " else {\n"
                        emit_C(t->children[2], level + 1)
                        C_str += ";\n" + idt + "}"
                    }
                }
                ast::_match()               { error("no match should remain at C emit"); }
                ast::_case()                { error("no case should remain at C emit"); }
                ast::_while()               {
                    C_str += idt + "while ("
                    emit_C(t->children[0], 0)
                    C_str += ") {\n"
                    emit_C(t->children[1], level + 1)
                    C_str += ";\n" + idt + "}"
                }
                ast::_for()                 {
                    C_str += idt + "for ("
                    emit_C(t->children[0], 0)
                    C_str += ";"
                    emit_C(t->children[1], 0)
                    C_str += ";"
                    emit_C(t->children[2], 0)
                    C_str += ") {\n"
                    emit_C(t->children[3], level+1)
                    C_str += ";\n" + idt + "}"
                }
                ast::_return()              {
                    C_str += idt + "return"
                    if (t->children.size == 1) {
                        C_str += " "
                        emit_C(t->children[0], 0)
                    }
                }
                ast::_break()               { C_str += idt + "break"; }
                ast::_continue()            { C_str += idt + "continue"; }
                ast::_defer()               { error("no defer should remain at C emit"); }
                ast::_call(add_scope)       {
                    if (is_compiler_intrinsic(get_ast_binding(t->children[0]))) {
                        if (t->children.size == 2) {
                            var intrinsic_name = get_ast_binding(t->children[0])->data._compiler_intrinsic.first
                            if (intrinsic_name == "&" || intrinsic_name == "*") {
                                C_str += idt + "(" + intrinsic_name + "("
                                emit_C(t->children[1], 0)
                                C_str += "))"
                            } else {
                                C_str += idt + "("
                                emit_C(t->children[1], 0)
                                C_str += ")." + intrinsic_name
                            }
                        } else if (t->children.size == 3) {
                            C_str += idt + "(("
                            emit_C(t->children[1], 0)
                            C_str += ")" + get_ast_binding(t->children[0])->data._compiler_intrinsic.first + "("
                            emit_C(t->children[2], 0)
                            C_str += "))"
                        } else error("Calling primitive intrinsic with not 1 or 2 arguments")
                    } else {
                        emit_C(t->children[0], level)
                        C_str += "("
                        for (var i = 1; i < t->children.size; i++;) {
                            if (i != 1)
                                C_str += ", "
                            emit_C(t->children[i], 0)
                        }
                        C_str += ")"
                    }
                }
                ast::_compiler_intrinsic(b) {
                    if b.first == "sizeof" {
                        C_str += "sizeof(" + to_c_type(b.third[0]) + ")"
                    } else {
                        /* this can happen cuz of templated primitive ops and is_top_level_item includes parentless stuff...*/
                    }
                }
                ast::_cast(b)               {
                    C_str += idt + "((" + to_c_type(b) + ")"
                    emit_C(t->children[0], 0)
                    C_str += ")"
                }
                ast::_value(b) {
                    if is_ptr(b.second->bound_to) && is_char(b.second->bound_to->_ptr->bound_to) {
                        C_str += "\""
                        b.first.for_each(fun(c: char) {
                            if (c == '\n')
                                C_str += "\\n"
                            else if (c == '\\')
                                C_str += "\\\\"
                            else if (c == '"')
                                C_str += "\\\""
                            else
                                C_str += c
                        })
                        C_str += "\""
                    } else {
                        C_str += idt + b.first;
                    }
                }
            }
        }

        emit_C(item, 0)
    }

    // We construct our real main entry function and add an emit_C pass for it,
    // starting generation of the entire program
    var real_main = _function(
                    str("main"),
                    binding_p(type::_fun(make_triple(make_pair(vec(
                                    make_pair(ref_type::_notref(), binding_p(type::_int())),
                                    make_pair(ref_type::_notref(), binding_p(type::_ptr(binding_p(type::_ptr(binding_p(type::_char()))))))
                                ),
                            make_pair(ref_type::_notref(), binding_p(type::_int()))
                        ), false, false))),
                    true, vec(
                                _identifier(str("argc"), binding_p(type::_int())),
                                _identifier(str("argv"), binding_p(type::_ptr(binding_p(type::_ptr(binding_p(type::_char())))))),
                                _return(vec(_call(false, vec(make_ast_binding("fmain"), make_ast_binding("argc"), make_ast_binding("argv")))))
                              )
                    )
    var top_unit = _translation_unit(str(), vec(
                       _import(make_ast_binding(kraken_file_name), set(str("*")), vec(
                            _identifier(kraken_file_name, binding_p(type::_void()))
                       )),
                       real_main
                   ))
    pass_poset.add_job(make_pair(real_main, str("emit_C")))

    pass_poset.run(fun(file_pass: pair<*tree<ast>, str>) {
        printlnerr("doing pass new style " + file_pass.second + " on " + to_string(file_pass.first->data))
        passes[file_pass.second](file_pass.first)
    })
    C_str = "#include <stdbool.h>\n" + C_type_forward_declaration_str + "\n" +
            str("\n").join(C_type_declaration_poset.get_sorted().map(fun(type_dec: *tree<ast>):str { return C_type_declaration_str_map[type_dec]; })) +
            "\n" + C_declaration_str + "\n" + C_str

    println()
    println()
    println("Finished with trees:")
    name_ast_map.for_each(fun(key: str, value: *tree<ast>) {
        printlnerr(key + ":")
        print_tree(value, 1)
        printlnerr("done")
    })

    var kraken_c_output_name = kraken_file_name + ".c"
    println(C_str)
    write_file(kraken_c_output_name, C_str)

    var c_flags = str("")
    if (compile_c) {
        var compile_string = "cc -g " + opt_str + " -Wno-int-to-pointer-cast -Wno-pointer-to-int-cast -Wno-incompatible-pointer-types -std=c99 " + c_flags + " " + kraken_c_output_name + " -o " + executable_name
        printlnerr(compile_string)
        system(compile_string)
    }

    return 0
}

fun parse_type(syntax: *tree<symbol>, declared_template_types: ref map<str, *binding<type>>): *binding<type> {
    return parse_type_helper(get_node("pre_reffed", syntax), declared_template_types)
}

fun parse_type_helper(syntax: *tree<symbol>, declared_template_types: ref map<str, *binding<type>>): *binding<type> {
    var next = get_node("pre_reffed", syntax)
    if (next != null<tree<symbol>>())
        return binding_p(type::_ptr(parse_type_helper(next, declared_template_types)))

    var ident = get_node("scoped_identifier", syntax)
    var func = get_node("function_type", syntax)
    var first_child_name = syntax->children[0]->data.name
    if (ident != null<tree<symbol>>()) {
        var ident_str = concat(ident)
        var template_inst = get_node("template_inst", syntax)
        if (template_inst != null<tree<symbol>>()) {
            var inst_with = get_nodes("type", template_inst).map(fun(s: *tree<symbol>): *binding<type> { return parse_type_helper(s, declared_template_types); })
            return binding_p(type::_obj(make_ast_binding(ident_str, inst_with)))
        } else {
            if (declared_template_types.contains_key(ident_str))
                return declared_template_types[ident_str]
            else
                return binding_p(type::_obj(make_ast_binding(ident_str)))
        }
    } else if (func != null<tree<symbol>>()) {
        error("function type parsing not implemented")
        var param_types = vec<pair<ref_type, *binding<type>>>()
        var return_type = make_pair(ref_type::_notref(), binding_p(type::_void()))
        var variadic = false
        var raw = false
        return binding_p(type::_fun(make_triple(make_pair(param_types, return_type), variadic, raw)))
    } else if (first_child_name == "\"void\"") {
        return binding_p(type::_void())
    } else if (first_child_name == "\"bool\"") {
        return binding_p(type::_bool())
    } else if (first_child_name == "\"char\"") {
        return binding_p(type::_char())
    } else if (first_child_name == "\"uchar\"") {
        return binding_p(type::_uchar())
    } else if (first_child_name == "\"short\"") {
        return binding_p(type::_short())
    } else if (first_child_name == "\"ushort\"") {
        return binding_p(type::_ushort())
    } else if (first_child_name == "\"int\"") {
        return binding_p(type::_int())
    } else if (first_child_name == "\"uint\"") {
        return binding_p(type::_uint())
    } else if (first_child_name == "\"long\"") {
        return binding_p(type::_long())
    } else if (first_child_name == "\"ulong\"") {
        return binding_p(type::_ulong())
    } else if (first_child_name == "\"float\"") {
        return binding_p(type::_float())
    } else if (first_child_name == "\"double\"") {
        return binding_p(type::_double())
    }
    error(syntax, "could not parse type " + first_child_name)
}

fun syntax_to_ast(file_name: str, syntax: *tree<symbol>, import_paths: ref vec<str>): *tree<ast> {
    var resolve_import_file = fun(file_name: str): str {
        var file_path = str()
        for (var i = 0; i < import_paths.size; i++;) {
            if (file_exists(import_paths[i] + file_name)) {
                if (file_path != "")
                    error("File: " + file_name + ", found in multiple import paths - at least two of [" + str(",").join(import_paths) + "]")
                file_path = import_paths[i] + file_name
            }
        }
        if (file_path == "")
            error("File: " + file_name + ", not found in any import path - none of [" + str(",").join(import_paths) + "]")
        return file_path
    }

    var syntax_to_ast_helper: fun(*tree<symbol>, ref map<str, *binding<type>>): *tree<ast> = fun(syntax: *tree<symbol>, declared_template_types: ref map<str, *binding<type>>): *tree<ast> {
        if (syntax->data.name == "import") {
            return _import(make_ast_binding(resolve_import_file(concat(syntax->children[1]) + ".krak")), from_vector(syntax->children.slice(2,-1).filter(fun(s:*tree<symbol>):bool {
                return s->data.name == "identifier" || s->data.data == "*"
            }).map(concat)), vec(syntax_to_ast_helper(syntax->children[1], declared_template_types)))
        } else if (syntax->data.name == "function") {

            var template = get_node("template_dec", syntax)
            var new_template_type_map = map<str, *binding<type>>()
            var with_added_declared_template_types = declared_template_types
            if (template != null<tree<symbol>>()) {
                get_nodes("template_param", template).for_each(fun(p: *tree<symbol>) {
                    var key = concat(p)
                    var value = binding_p(type::_template_placeholder())
                    new_template_type_map[key] = value
                    with_added_declared_template_types[key] = value
                })
            }

            var parameters  = get_nodes("typed_parameter", syntax).map(fun(x: *tree<symbol>): pair<ref_type, *tree<ast>> {
                if get_node("\"ref\"", get_node("type", x)) != null<tree<symbol>>() {
                    return make_pair(ref_type::_ref(), syntax_to_ast_helper(x, with_added_declared_template_types))
                } else {
                    return make_pair(ref_type::_notref(), syntax_to_ast_helper(x, with_added_declared_template_types))
                }
            })
            var return_type = make_pair(ref_type::_unknown(), null<binding<type>>())
            var return_type_node = get_node("typed_return", syntax)
            if return_type_node != null<tree<symbol>>() {
                if get_node("\"ref\"", get_node("type", return_type_node)) != null<tree<symbol>>() {
                    return_type = make_pair(ref_type::_ref(), parse_type(get_node("type", return_type_node), with_added_declared_template_types))
                } else {
                    return_type = make_pair(ref_type::_notref(), parse_type(get_node("type", return_type_node), with_added_declared_template_types))
                }
            } else {
                return_type = make_pair(ref_type::_notref(), binding_p(type::_void()))
            }
            var function_type = binding_p(type::_fun(make_triple(
                                                                    make_pair(parameters.map(fun(i: pair<ref_type, *tree<ast>>): pair<ref_type, *binding<type>> return make_pair(i.first, i.second->data._identifier.second);),
                                                                              return_type),
                                                                    get_node("\"...\"", syntax) != null<tree<symbol>>(),
                                                                    false /*get_node("\"run\"", syntax) != null<tree<symbol>>()*/)))
            var body_syntax = get_node("statement", syntax)
            var body = vec<*tree<ast>>()
            if body_syntax != null<tree<symbol>>() {
                body = vec(syntax_to_ast_helper(body_syntax, with_added_declared_template_types))
            }
            var n = _function(concat(get_node("func_identifier", syntax)),
                              function_type, get_node("\"ext\"", syntax) != null<tree<symbol>>(),
                              parameters.map(fun(i: pair<ref_type, *tree<ast>>): *tree<ast> return i.second;) + body)
            if (new_template_type_map.size() > 0) {
                return _template(n->data._function.first, new_template_type_map, vec(n))
            } else {
                return n
            }
        } else if (syntax->data.name == "typed_parameter")
            return _identifier(concat(get_node("identifier", syntax)), parse_type(get_node("type", syntax), declared_template_types))
        else if (syntax->data.name == "type_def") {

            var template = get_node("template_dec", syntax)
            var new_template_type_map = map<str, *binding<type>>()
            var with_added_declared_template_types = declared_template_types
            if (template != null<tree<symbol>>()) {
                get_nodes("template_param", template).for_each(fun(p: *tree<symbol>) {
                    var key = concat(p)
                    var value = binding_p(type::_template_placeholder())
                    new_template_type_map[key] = value
                    with_added_declared_template_types[key] = value
                })
            }

            var n = _type_def(concat(get_node("identifier", syntax)),
                             get_nodes("declaration_statement", syntax).map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, with_added_declared_template_types);))

            if (new_template_type_map.size() > 0) {
                return _template(n->data._type_def, new_template_type_map, vec(n))
            } else {
                return n
            }
        } else if (syntax->data.name == "adt_def") {

            var template = get_node("template_dec", syntax)
            var new_template_type_map = map<str, *binding<type>>()
            var with_added_declared_template_types = declared_template_types
            if (template != null<tree<symbol>>()) {
                get_nodes("template_param", template).for_each(fun(p: *tree<symbol>) {
                    var key = concat(p)
                    var value = binding_p(type::_template_placeholder())
                    new_template_type_map[key] = value
                    with_added_declared_template_types[key] = value
                })
            }

            var n = _adt_def(concat(get_node("identifier", syntax)),
                             get_nodes("adt_option", syntax).map(fun(s: *tree<symbol>): *tree<ast> {
                                var option_type = get_node("type", s)
                                if (option_type != null<tree<symbol>>())
                                    return _identifier(concat(get_node("identifier", s)), parse_type(option_type, with_added_declared_template_types))
                                else
                                    return _identifier(concat(get_node("identifier", s)), binding_p(type::_void()))
                             }))
            if (new_template_type_map.size() > 0) {
                return _template(n->data._adt_def, new_template_type_map, vec(n))
            } else {
                return n
            }
        } else if (syntax->data.name == "statement")
            return syntax_to_ast_helper(syntax->children[0], declared_template_types)
        else if (syntax->data.name == "code_block")
            return _block(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "if_statement")
            return _if(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "for_loop")
            return _for(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "while_loop")
            return _while(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "return_statement")
            return _return(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "defer_statement")
            return _defer(syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
        else if (syntax->data.name == "break_statement")
            return _break()
        else if (syntax->data.name == "continue_statement")
            return _continue()
        else if (syntax->data.name == "match_statement") {
            return _match(vec(syntax_to_ast_helper(get_node("boolean_expression", syntax), declared_template_types)) +
                              get_nodes("case_statement", syntax).map(fun(s: *tree<symbol>): *tree<ast> {
                                    return _case(s->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
                              }))
        } else if (syntax->data.name == "declaration_statement") {
            var t = binding_p(type::_unknown())
            var type_syntax = get_node("type", syntax)
            if type_syntax != null<tree<symbol>>()
                t = parse_type(type_syntax, declared_template_types)
            var children = vec(_identifier(concat(get_node("identifier", syntax)), t))
            children += get_nodes("boolean_expression", syntax).map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);)
            return _declaration(children)
        } else if (syntax->data.name == "assignment_statement") {
            return _call(false, vec(make_ast_binding("op" + concat(syntax->children[1])),
                                   syntax_to_ast_helper(syntax->children[0], declared_template_types),
                                   syntax_to_ast_helper(syntax->children[2], declared_template_types)))
        } else if (syntax->data.name == "function_call") {
            // if method, pull out
            if syntax->children[0]->data.name == "unarad" && syntax->children[0]->children[0]->data.name == "access_operation" {
                println("doing a method call!")
                /*return _call(vec(syntax_to_ast_helper(syntax->children[0]->children[0]->children[2], declared_template_types)) + syntax_to_ast_helper(syntax->children[0]->children[0]->children[0], declared_template_types) + get_nodes("parameter", syntax).map(fun(s: *tree<symbol>): *tree<ast> {*/
                return _call(true, vec(make_ast_binding(concat(syntax->children[0]->children[0]->children[2]))) + syntax_to_ast_helper(syntax->children[0]->children[0]->children[0], declared_template_types) + get_nodes("parameter", syntax).map(fun(s: *tree<symbol>): *tree<ast> {
                                    return syntax_to_ast_helper(s->children[0], declared_template_types)
                             }))
            } else {
                println("NOT doing a method call! - is " + syntax->children[0]->data.name + " not unrad, or")
                println(syntax->children[0]->children[0]->data.name + " not access_operation")
                return _call(false, vec(syntax_to_ast_helper(syntax->children[0], declared_template_types)) + get_nodes("parameter", syntax).map(fun(s: *tree<symbol>): *tree<ast> {
                                    return syntax_to_ast_helper(s->children[0], declared_template_types)
                             }))
            }
        } else if (syntax->data.name == "access_operation") {
                // somehow note / do the crazier scope lookup
                // also handle . vs ->
                return _call(true, vec(make_ast_binding(concat(syntax->children[2])), syntax_to_ast_helper(syntax->children[0], declared_template_types)))
        } else if (syntax->data.name == "boolean_expression" ||
                 syntax->data.name == "and_boolean_expression" ||
                 syntax->data.name == "bitwise_or" ||
                 syntax->data.name == "bitwise_xor" ||
                 syntax->data.name == "bitwise_and" ||
                 syntax->data.name == "bool_exp" ||
                 syntax->data.name == "expression" ||
                 syntax->data.name == "shiftand" ||
                 syntax->data.name == "term" ||
                 syntax->data.name == "factor" ||
                 syntax->data.name == "unarad") {
            if (syntax->children.size == 1) {
                return syntax_to_ast_helper(syntax->children[0], declared_template_types)
            } else if (syntax->children.size == 2) {
                var template_inst = get_node("template_inst", syntax)
                if (template_inst != null<tree<symbol>>()) {
                    if (syntax->children[0]->data.name != "scoped_identifier")
                        error(syntax, "Unexpected template instantiation (not on an identifier)")
                    return make_ast_binding(concat(syntax->children[0]), get_nodes("type", template_inst).map(fun(s: *tree<symbol>): *binding<type> {
                        return parse_type(s, declared_template_types);
                    }))
                } else if (syntax->children[0]->data.terminal) {
                    return _call(true, vec(make_ast_binding("op" + concat(syntax->children[0])),
                                     syntax_to_ast_helper(syntax->children[1], declared_template_types)))
                } else {
                    return _call(true, vec(make_ast_binding("op" + concat(syntax->children[1])),
                                     syntax_to_ast_helper(syntax->children[0], declared_template_types)))
                }
            } else {
                return _call(true, vec(make_ast_binding("op" + concat(syntax->children[1])),
                                 syntax_to_ast_helper(syntax->children[0], declared_template_types),
                                 syntax_to_ast_helper(syntax->children[2], declared_template_types)))
            }
        } else if (syntax->data.name == "cast_expression") {
            return _cast(parse_type(get_node("type", syntax), declared_template_types), vec(syntax_to_ast_helper(syntax->children[0], declared_template_types)))
        } else if (syntax->data.name == "compiler_intrinsic") {
            var name = concat(get_node("identifier", syntax))
            if name != "sizeof" {
                error("unknown compiler intrinsic " + name)
            }
            return _compiler_intrinsic(name, binding_p(type::_ulong()), vec(parse_type(get_node("type", syntax), declared_template_types)))
        } else if (syntax->data.name == "number") {
            var number_string = concat(syntax)
            if (number_string.contains('.'))
                return _value(number_string, binding_p(type::_double()))
            else
                return _value(number_string, binding_p(type::_int()))
        } else if (syntax->data.name == "string") {
            var value_str = concat(syntax)
            var start = 1
            var end = value_str.length() -1
            if (value_str.length() > 3 && value_str[1] == '"' && value_str[2] == '"') {
                value_str = value_str.slice(3,-4)
            } else {
                var new_str.construct(end-start): str
                var escaped = false
                for (var i = 1; i < value_str.length()-1; i++;) {
                    if (escaped) {
                        escaped = false
                        if (value_str[i] == 'n')
                            new_str += '\n'
                        else if (value_str[i] == 't')
                            new_str += '\t'
                        else
                            new_str += value_str[i]
                    } else if (value_str[i] == '\\') {
                        escaped = true
                    } else {
                        new_str += value_str[i]
                    }
                }
                value_str = new_str
            }
            return _value(value_str, binding_p(type::_ptr(binding_p(type::_char()))))
        } else if (syntax->data.name == "bool")
            return _value(concat(syntax), binding_p(type::_bool()))
        else if (syntax->data.name == "scoped_identifier" || syntax->data.name == "identifier")
            return make_ast_binding(concat(syntax))
        else {
            error(syntax, "Cannot transform")
        }
    }
    var declared_template_types = map<str, *binding<type>>()
    var result = _translation_unit(file_name, syntax->children.map(fun(x: *tree<symbol>): *tree<ast> return syntax_to_ast_helper(x, declared_template_types);))
    return result
}
fun print_tree<T>(t: *tree<T>, level: int) {
    printlnerr("\t" * level + to_string(t->data))
    for (var i = 0; i < t->children.size; i++;)
        if (t->children[i])
            print_tree(t->children[i], level+1)
        else
            printlnerr("\t" * (level + 1) + "null!")
}
fun get_node(lookup: *char, parent: *tree<symbol>): *tree<symbol> {
    return get_node(str(lookup), parent)
}
fun get_node(lookup: str, parent: *tree<symbol>): *tree<symbol> {
    var results = get_nodes(lookup, parent)
    if (results.size > 1)
        error(parent, "get node too many results!")
    if (results.size)
        return results[0]
    return null<tree<symbol>>()
}
fun get_nodes(lookup: *char, parent: *tree<symbol>): vec<*tree<symbol>> {
    return get_nodes(str(lookup), parent)
}
fun get_nodes(lookup: str, parent: *tree<symbol>): vec<*tree<symbol>> {
    return parent->children.filter(fun(node: *tree<symbol>):bool return node->data.name == lookup;)
}
fun concat(node: *tree<symbol>): str {
    var str.construct(): str
    if (node->data.data != "no_value")
        str += node->data.data
    node->children.for_each(fun(child: *tree<symbol>) str += concat(child);)
    return str
}
fun get_first_terminal(source: *tree<symbol>): *tree<symbol> {
    if (!source)
        return null<tree<symbol>>()
    if (source->data.terminal)
        return source
    if (source->children.size == 0)
        return null<tree<symbol>>()
    return get_first_terminal(source->children.first())
}
fun error(source: *tree<symbol>, message: *char) error(source, str(message));
fun error(source: *tree<symbol>, message: str) {
    var first = get_first_terminal(source)
    if (first)
        error("***error |" + concat(source) + "| *** " + first->data.source + ": " + first->data.position + " " + message)
    error(message)
}
fun trim(parse_tree: *tree<symbol>) {
    remove_node(symbol("$NULL$", false), parse_tree)
    remove_node(symbol("WS", false), parse_tree)
    // the terminals have " around them, which we have to escape
    remove_node(symbol("\"\\(\"", true), parse_tree)
    remove_node(symbol("\"\\)\"", true), parse_tree)
    remove_node(symbol("\"template\"", true), parse_tree)
    remove_node(symbol("\"return\"", true), parse_tree)
    remove_node(symbol("\"defer\"", true), parse_tree)
    remove_node(symbol("\";\"", true), parse_tree)
    remove_node(symbol("line_end", false), parse_tree)
    remove_node(symbol("\"{\"", true), parse_tree)
    remove_node(symbol("\"}\"", true), parse_tree)
    remove_node(symbol("\"(\"", true), parse_tree)
    remove_node(symbol("\")\"", true), parse_tree)
    remove_node(symbol("\"if\"", true), parse_tree)
    remove_node(symbol("\"else\"", true), parse_tree)
    remove_node(symbol("\"while\"", true), parse_tree)
    remove_node(symbol("\"for\"", true), parse_tree)
    remove_node(symbol("\"__if_comp__\"", true), parse_tree)
    remove_node(symbol("\"comp_simple_passthrough\"", true), parse_tree)
    /*remove_node(symbol("obj_nonterm", false), parse_tree)*/
    remove_node(symbol("adt_nonterm", false), parse_tree)

    collapse_node(symbol("case_statement_list", false), parse_tree)
    collapse_node(symbol("opt_param_assign_list", false), parse_tree)
    collapse_node(symbol("param_assign_list", false), parse_tree)
    collapse_node(symbol("opt_typed_parameter_list", false), parse_tree)
    collapse_node(symbol("opt_parameter_list", false), parse_tree)
    collapse_node(symbol("intrinsic_parameter_list", false), parse_tree)
    collapse_node(symbol("identifier_list", false), parse_tree)
    collapse_node(symbol("adt_option_list", false), parse_tree)
    collapse_node(symbol("statement_list", false), parse_tree)
    collapse_node(symbol("parameter_list", false), parse_tree)
    collapse_node(symbol("typed_parameter_list", false), parse_tree)
    collapse_node(symbol("unorderd_list_part", false), parse_tree)
    collapse_node(symbol("if_comp_pred", false), parse_tree)
    collapse_node(symbol("declaration_block", false), parse_tree)
    collapse_node(symbol("type_list", false), parse_tree)
    collapse_node(symbol("opt_type_list", false), parse_tree)
    collapse_node(symbol("template_param_list", false), parse_tree)
    collapse_node(symbol("trait_list", false), parse_tree)
    collapse_node(symbol("dec_type", false), parse_tree)
}
fun remove_node(remove: symbol, parse_tree: *tree<symbol>) {
    var to_process = stack<*tree<symbol>>()
    to_process.push(parse_tree)
    while(!to_process.empty()) {
        var node = to_process.pop()
        for (var i = 0; i < node->children.size; i++;) {
            if (!node->children[i] || node->children[i]->data.equal_wo_data(remove)) {
                node->children.remove(i)
                i--;
            } else {
                to_process.push(node->children[i])
            }
        }
    }
}
fun collapse_node(remove: symbol, parse_tree: *tree<symbol>) {
    var to_process = stack<*tree<symbol>>()
    to_process.push(parse_tree)
    while(!to_process.empty()) {
        var node = to_process.pop()
        for (var i = 0; i < node->children.size; i++;) {
            if (node->children[i]->data.equal_wo_data(remove)) {
                var add_children = node->children[i]->children;
                // stick child's children between the current children divided
                // on i, without including i
                node->children = node->children.slice(0,i) +
                                    add_children + node->children.slice(i+1,-1)
                i--;
            } else {
                to_process.push(node->children[i])
            }
        }
    }
}
