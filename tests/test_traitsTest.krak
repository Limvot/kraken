import io:*;

typedef NoTraits {};

typedef Trait1 (FirstTrait) {};
typedef Trait2 (SecondTrait) {};
typedef TwoTrait (FirstTrait, SecondTrait) {};
typedef AlreadySpecilized (FirstTrait, SecondTrait) {};

fun OneTwoFunc<T>(obj: T): void {
    println("No Traits");
}

fun OneTwoFunc<T(FirstTrait)>(obj: T): void {
    println("First Trait");
}

fun OneTwoFunc<T(SecondTrait)>(obj: T): void {
    println("Second Trait");
}

fun OneTwoFunc<T(FirstTrait, SecondTrait)>(obj: T): void {
    println("Both Traits");
}
/*
template <AlreadySpecilized> |void| OneTwoFunc(|AlreadySpecilized| obj) {
    println("Already Specilized");
}
*/
//This should work for objects too!
//To test, we cycle the mapping of traits

typedef OneTwoObj<T> (FirstTrait) {};
typedef OneTwoObj<T(FirstTrait)> (SecondTrait) {};
typedef OneTwoObj<T(SecondTrait)> (FirstTrait, SecondTrait) {};
typedef OneTwoObj<T(FirstTrait, SecondTrait)> {};
/*
 *typedef template<AlreadySpecilized> OneTwoObj {
 *    void proveSpecilized() {
 *        println("I'm specilized!");
 *    }
 *};
 */

fun main(): int {
    var a: NoTraits;
    var b: Trait1;
    var c: Trait2;
    var d: TwoTrait;
    var e: AlreadySpecilized;

    OneTwoFunc<NoTraits>(a);
    OneTwoFunc<Trait1>(b);
    OneTwoFunc<Trait2>(c);
    OneTwoFunc<TwoTrait>(d);
//    OneTwoFunc<AlreadySpecilized>(e);

    println();

    var alpha: OneTwoObj<NoTraits>;
    var beta: OneTwoObj<Trait1>;
    var gamma: OneTwoObj<Trait2>;
    var delta: OneTwoObj<TwoTrait>;
//    |OneTwoObj<AlreadySpecilized>| epsilon;

    OneTwoFunc<OneTwoObj<NoTraits>>(alpha);
    OneTwoFunc<OneTwoObj<Trait1>>(beta);
    OneTwoFunc<OneTwoObj<Trait2>>(gamma);
    OneTwoFunc<OneTwoObj<TwoTrait>>(delta);

    //We can't pass along our inner part, so let's just make sure that it is the right object.
    //epsilon.proveSpecilized();

    return 0;
}
