import io:*
import grammer:*
import parser:*
import string:*
import util:*
import symbol:*
import tree:*
import serialize:*
import interpreter:*
import os:*
import ast_transformation:*
import adt_lower:*
import defer_lower:*
import c_line_control:*
import c_generator:*
import compiler_version


fun main(argc: int, argv: **char):int {
    if (argc <= 1) {
        error("No input file!\n Call with one argument (the input file), or two arguments (input file and output name)")
    } else if (string(argv[1]) == "-v" || string(argv[1]) == "--version") {
        println(compiler_version::version_string)
        exit(0)
    }
    var input_file_offset = 1
    var interpret_instead = false
    var argv1_str = string(argv[1])
    var opt_str = string("-O3")
    var line_ctrl = false
    if (argv1_str == "-i") {
        interpret_instead = true
        input_file_offset++
    } else if (argv1_str.length() > 2 && argv1_str.slice(0,2) == "-O") {
        opt_str = argv1_str
        input_file_offset++
    } else if (argv1_str == "-g") {
        line_ctrl = true
        input_file_offset++
    }
    var kraken_file_name = string(argv[input_file_offset])
    var executable_name = string(".").join(kraken_file_name.split('.').slice(0,-2))
    if (argc == input_file_offset+2)
        executable_name = string(argv[input_file_offset+1])
    // delay construction until we either load it or copy construct it
    var gram: grammer
    var base_dir = string("/").join(string(argv[0]).split('/').slice(0,-2))
    var file_name = base_dir + "/krakenGrammer.kgm"
    var compiled_name = file_name + string(".comp_new")
    var compiled_version = 1
    var file_contents = read_file(file_name)
    var loaded_and_valid = false

    if (file_exists(compiled_name)) {
        /*println("cached file exists")*/
        var pos = 0
        var binary = read_file_binary(compiled_name)
        /*println("read file!")*/
        var saved_version = 0
        unpack(saved_version, pos) = unserialize<int>(binary, pos)
        if (saved_version == compiled_version) {
            var cached_contents = string()
            unpack(cached_contents, pos) = unserialize<string>(binary, pos)
            if (cached_contents == file_contents) {
                /*println("loaded_and_valid, using cached version!")*/
                loaded_and_valid = true
                pos = gram.unserialize(binary, pos)
            } else println("contents different")
        } else println("version number different")
    } else {
        println("cached file does not exist")
    }
    if (!loaded_and_valid) {
        println("Not loaded_and_valid, re-generating and writing out")
        /*gram = load_grammer(file_contents)*/
        // since we now don't construct before hand
        gram.copy_construct(&load_grammer(file_contents))
        println("grammer loaded, calculate_first_set")
        gram.calculate_first_set()
        println("grammer loaded, calculate_state_automaton")
        gram.calculate_state_automaton()
        println("calculated, writing out")
        write_file_binary(compiled_name, serialize(compiled_version) + serialize(file_contents) + serialize(gram))
        println("done writing")
    }

    var parse1.construct(&gram): parser
    /*var parse2.construct(&gram): parser*/
    /*var parse3.construct(&gram): parser*/
    /*var parse4.construct(&gram): parser*/
    /*var parse5.construct(&gram): parser*/
    /*var parse6.construct(&gram): parser*/
    /*var parse7.construct(&gram): parser*/
    /*var parse8.construct(&gram): parser*/
    var ast_pass.construct(): ast_transformation
    var parsers = vector(parse1)
    /*var parsers = vector(parse1,parse2,parse3,parse4)*/
    /*var parsers = vector(parse1,parse2,parse3,parse4,parse5,parse6)*/
    /*var parsers = vector(parse1,parse2,parse3,parse4,parse5,parse6,parse7,parse8)*/
    var importer.construct(parsers, ast_pass, vector(string(), base_dir + "/stdlib/")): importer
    importer.import(kraken_file_name)
    // Passes
    printlnerr("Lowering ADTs")
    adt_lower(&importer.name_ast_map, &importer.ast_pass.ast_to_syntax)
    printlnerr("Lowering Defer")
    defer_lower(&importer.name_ast_map, &importer.ast_pass.ast_to_syntax)
    if (interpret_instead) {
        printlnerr("Interpreting!")
        var interpret.construct(importer.name_ast_map, importer.ast_pass.ast_to_syntax): interpreter
        interpret.call_main()
    } else {
        if (line_ctrl) {
            printlnerr("running C-specific passes")
            printlnerr("running #line")
            c_line_control(&importer.name_ast_map, &importer.ast_pass.ast_to_syntax)
        }
        printlnerr("Generating C")
        var c_generator.construct(): c_generator
        var c_output_pair = c_generator.generate_c(importer.name_ast_map, importer.ast_pass.ast_to_syntax)
        var kraken_c_output_name = kraken_file_name + ".c"
        write_file(kraken_c_output_name, c_output_pair.first)
        /*println(string("linker string: ") + c_output_pair.second)*/
        var compile_string = "cc -g " + opt_str + " -Wno-int-to-pointer-cast -Wno-pointer-to-int-cast -std=c99 " + c_output_pair.second + " " + kraken_c_output_name + " -o " + executable_name
        printlnerr(compile_string)
        system(compile_string)
    }

    return 0
}

