((wrap (vau root_env (quote)
((wrap (vau (let1)
(let1 lambda (vau se (p b1) (wrap (eval (array vau p b1) se)))
(let1 current-env (vau de () de)
(let1 cons (lambda (h t) (concat (array h) t))
(let1 Y (lambda (f3)
    ((lambda (x1) (x1 x1))
     (lambda (x2) (f3 (lambda (& y) (lapply (x2 x2) y))))))
(let1 vY (lambda (f)
    ((lambda (x3) (x3 x3))
     (lambda (x4) (f (vau de1 (& y) (vapply (x4 x4) y de1))))))
(let1 let (vY (lambda (recurse) (vau de2 (vs b) (cond (= (len vs) 0) (eval b de2)
                                                     true           (vapply let1 (array (idx vs 0) (idx vs 1) (array recurse (slice vs 2 -1) b)) de2)))))
 (let (
         lcompose (lambda (g f) (lambda (& args) (lapply g (array (lapply f args)))))
         rec-lambda (vau se (n p b) (eval (array Y (array lambda (array n) (array lambda p b))) se))
         if (vau de (con than & else) (cond (eval con de) (eval than de)
                                            (> (len else) 0) (eval (idx else 0) de)
                                            true false))

         map (lambda (f5 l5)
             ; now maybe errors on can't find helper?
             (let (helper (rec-lambda recurse (f4 l4 n4 i4)
                                             (cond (= i4 (len l4))         n4
                                                   (<= i4 (- (len l4) 4))  (recurse f4 l4 (concat n4 (array
                                                                                                 (f4 (idx l4 (+ i4 0)))
                                                                                                 (f4 (idx l4 (+ i4 1)))
                                                                                                 (f4 (idx l4 (+ i4 2)))
                                                                                                 (f4 (idx l4 (+ i4 3)))
                                                                                                 )) (+ i4 4))
                                                   true                  (recurse f4 l4 (concat n4 (array (f4 (idx l4 i4)))) (+ i4 1)))))
                  (helper f5 l5 (array) 0)))


        map_i (lambda (f l)
            (let (helper (rec-lambda recurse (f l n i)
                                            (cond (= i (len l))         n
                                                  (<= i (- (len l) 4))  (recurse f l (concat n (array
                                                                                                (f (+ i 0) (idx l (+ i 0)))
                                                                                                (f (+ i 1) (idx l (+ i 1)))
                                                                                                (f (+ i 2) (idx l (+ i 2)))
                                                                                                (f (+ i 3) (idx l (+ i 3)))
                                                                                                )) (+ i 4))
                                                  true                  (recurse f l (concat n (array (f i (idx l i)))) (+ i 1)))))
                 (helper f l (array) 0)))

        filter_i (lambda (f l)
               (let (helper (rec-lambda recurse (f l n i)
                                            (if (= i (len l))
                                                n
                                                (if (f i (idx l i)) (recurse f l (concat n (array (idx l i))) (+ i 1))
                                                                    (recurse f l n (+ i 1))))))
                    (helper f l (array) 0)))
        filter (lambda (f l) (filter_i (lambda (i x) (f x)) l))

        ; Huge thanks to Oleg Kiselyov for his fantastic website
        ; http://okmij.org/ftp/Computation/fixed-point-combinators.html
        Y* (lambda (& l)
            ((lambda (u) (u u))
             (lambda (p)
                (map (lambda (li) (lambda (& x) (lapply (lapply li (p p)) x))) l))))
        vY* (lambda (& l)
            ((lambda (u) (u u))
             (lambda (p)
                (map (lambda (li) (vau ide (& x) (vapply (lapply li (p p)) x ide))) l))))

        let-rec (vau de (name_func body)
                    (let (names (filter_i (lambda (i x) (= 0 (% i 2))) name_func)
                          funcs (filter_i (lambda (i x) (= 1 (% i 2))) name_func)
                          overwrite_name (idx name_func (- (len name_func) 2)))
                          (eval (array let (concat (array overwrite_name (concat (array Y*) (map (lambda (f) (array lambda names f)) funcs)))
                                                                                (lapply concat (map_i (lambda (i n) (array n (array idx overwrite_name i))) names)))
                                       body) de)))
        let-vrec (vau de (name_func body)
                    (let (names (filter_i (lambda (i x) (= 0 (% i 2))) name_func)
                          funcs (filter_i (lambda (i x) (= 1 (% i 2))) name_func)
                          overwrite_name (idx name_func (- (len name_func) 2)))
                          (eval (array let (concat (array overwrite_name (concat (array vY*) (map (lambda (f) (array lambda names f)) funcs)))
                                                                                (lapply concat (map_i (lambda (i n) (array n (array idx overwrite_name i))) names)))
                                       body) de)))

        flat_map (lambda (f l)
            (let (helper (rec-lambda recurse (f l n i)
                                            (if (= i (len l))
                                                n
                                                (recurse f l (concat n (f (idx l i))) (+ i 1)))))
                 (helper f l (array) 0)))
        flat_map_i (lambda (f l)
            (let (helper (rec-lambda recurse (f l n i)
                                            (if (= i (len l))
                                                n
                                                (recurse f l (concat n (f i (idx l i))) (+ i 1)))))
                 (helper f l (array) 0)))

        ; with all this, we make a destrucutring-capable let
        let (let (
            destructure_helper (rec-lambda recurse (vs i r)
                (cond (= (len vs) i)      r
                      (array? (idx vs i)) (let (bad_sym (str-to-symbol (str (idx vs i)))
                                                ;new_vs (flat_map_i (lambda (i x) (array x (array idx bad_sym i))) (slice (idx vs i) 1 -1))
                                                new_vs (flat_map_i (lambda (i x) (array x (array idx bad_sym i))) (idx vs i))
                                                )
                                                (recurse (concat new_vs (slice vs (+ i 2) -1)) 0 (concat r (array bad_sym (idx vs (+ i 1))))))
                      true                (recurse vs (+ i 2) (concat r (slice vs i (+ i 2))))
            ))) (vau de (vs b) (vapply let (array (destructure_helper vs 0 (array)) b) de)))

        ; and a destructuring-capable lambda!
        only_symbols (rec-lambda recurse (a i) (cond (= i (len a))       true
                                                     (symbol? (idx a i)) (recurse a (+ i 1))
                                                     true                false))

        ; Note that if macro_helper is inlined, the mapping lambdas will close over
        ; se, and then not be able to be taken in as values to the maps, and the vau
        ; will fail to partially evaluate away.
        lambda (let (macro_helper (lambda (p b) (let (
                        sym_params (map (lambda (param) (if (symbol? param) param
                                                                            (str-to-symbol (str param)))) p)
                        body (array let (flat_map_i (lambda (i x) (array (idx p i) x)) sym_params) b)
                      ) (array vau sym_params body))))
                    (vau se (p b) (if (only_symbols p 0) (vapply lambda (array p b) se)
                                                         (wrap (eval (macro_helper p b) se)))))

        ; and rec-lambda - yes it's the same definition again
        rec-lambda (vau se (n p b) (eval (array Y (array lambda (array n) (array lambda p b))) se))

        nil (array)
        not (lambda (x) (if x false true))
        or  (let (macro_helper (rec-lambda recurse (bs i) (cond (= i       (len bs)) false
                                                                (= (+ 1 i) (len bs)) (idx bs i)
                                                                true       (array let (array 'tmp (idx bs i)) (array if 'tmp 'tmp (recurse bs (+ i 1)))))))
                 (vau se (& bs) (eval (macro_helper bs 0) se)))
        and (let (macro_helper (rec-lambda recurse (bs i) (cond (= i       (len bs)) true
                                                                (= (+ 1 i) (len bs)) (idx bs i)
                                                                true       (array let (array 'tmp (idx bs i)) (array if 'tmp (recurse bs (+ i 1)) 'tmp)))))
                 (vau se (& bs) (eval (macro_helper bs 0) se)))



        foldl (let (helper (rec-lambda recurse (f z vs i) (if (= i (len (idx vs 0))) z
                                                                           (recurse f (lapply f (cons z (map (lambda (x) (idx x i)) vs))) vs (+ i 1)))))
                   (lambda (f z & vs) (helper f z vs 0)))
        foldr (let (helper (rec-lambda recurse (f z vs i) (if (= i (len (idx vs 0))) z
                                                                           (lapply f (cons (recurse f z vs (+ i 1)) (map (lambda (x) (idx x i)) vs))))))
                   (lambda (f z & vs) (helper f z vs 0)))
        reverse (lambda (x) (foldl (lambda (acc i) (cons i acc)) (array) x))
        zip (lambda (& xs) (lapply foldr (concat (array (lambda (a & ys) (cons ys a)) (array)) xs)))

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Begin kludges to align with Scheme kludges
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        dlet (vau se (inners body) (vapply let (array (lapply concat inners) body) se))
        cond (vau se (& inners) (vapply cond (lapply concat inners) se))
        print   log
        println log
        dlambda lambda
        mif (vau de (c & bs) (vapply if (cons (array let (array 'tmp c) (array and (array != 'tmp) 'tmp)) bs) de))
        ;mif (vau de (c & bs) (eval (concat (array if (array let (array 'tmp c) (array and (array != 'tmp) 'tmp))) bs) de))


 )
 (dlet (

      (empty_dict-list (array))
      (put-list (lambda (m k v) (cons (array k v) m)))
      (get-list (lambda (d k) ((rec-lambda recurse (k d len_d i) (cond ((= len_d i)             false)
                                                                       ((= k (idx (idx d i) 0)) (idx d i))
                                                                       (true                    (recurse k d len_d (+ 1 i)))))
                                k d (len d) 0)))

      ;(combine_hash     (lambda (a b) (+ (* 37 a) b)))
      (combine_hash     (lambda (a b) (band #xFFFFFFFFFFFFFF (+ (* 37 a) b))))
      (hash_bool        (lambda (b) (if b 2 3)))
      (hash_num         (lambda (n) (combine_hash 5 n)))
      ;(hash_string      (lambda (s) (foldl combine_hash 7  (map char->integer (string->list s)))))
      (hash_string      (lambda (s) (foldl combine_hash 7 s)))
      ;(hash_string      (lambda (s) (foldl combine_hash 102233  (map char->integer (string->list s)))))

      (empty_dict-tree nil)
      (trans-key (lambda (k) (cond ((string? k) (hash_string k))
                                   ((symbol? k) (hash_string (get-text k)))
                                   (true        k))))
      (put-helper (rec-lambda put-helper (m hk k v) (cond ((nil? m)                (array hk        k         v          nil                           nil))
                                                           ((and (= hk (idx m 0))
                                                                 (= k  (idx m 1))) (array hk        k         v         (idx m 3)                     (idx m 4)))
                                                           ((< hk (idx m 0))       (array (idx m 0) (idx m 1) (idx m 2) (put-helper (idx m 3) hk k v) (idx m 4)))
                                                           (true                   (array (idx m 0) (idx m 1) (idx m 2) (idx m 3)                     (put-helper (idx m 4) hk k v))))))
      (put-tree (lambda (m k v) (put-helper m (trans-key k) k v)))
      (get-helper (rec-lambda get-helper (m hk k) (cond ((nil? m)                     false)
                                                        ((and (= hk (idx m 0))
                                                              (= k  (idx m 1)))       (array k (idx m 2)))
                                                        ((< hk (idx m 0))             (get-helper (idx m 3) hk k))
                                                        (true                         (get-helper (idx m 4) hk k)))))
      (get-tree (lambda (m k) (get-helper m (trans-key k) k)))

      ;(empty_dict empty_dict-list)
      ;(put put-list)
      ;(get get-list)
      (empty_dict empty_dict-tree)
      (put put-tree)
      (get get-tree)

      (get-value (lambda (d k) (dlet ((result (get d k)))
                                    (if (array? result) (idx result 1)
                                                       (error (str "could not find " k " in " d))))))
      (get-value-or-false (lambda (d k) (dlet ((result (get d k)))
                                    (if (array? result) (idx result 1)
                                                       false))))



    (in_array (dlet ((helper (rec-lambda recurse (x a len_a i) (cond ((= i len_a)     false)
                                                                     ((= x (idx a i)) true)
                                                                     (true            (recurse x a len_a (+ i 1)))))))
                   (lambda (x a) (helper x a (len a) 0))))
    (array_item_union (lambda (a bi) (if (in_array bi a) a (cons bi a))))
    (array_union (lambda (a b) (foldl array_item_union a b)))
    (array_union_without (lambda (wo a b)
                           (foldl (lambda (o xi) (if (or (= wo xi) (in_array xi o)) o (cons xi o)))
                                  (array) (concat a b))))

    (val?                               (lambda (x) (= 'val (idx x 0))))
    (marked_array?                      (lambda (x) (= 'marked_array (idx x 0))))
    (marked_symbol?                     (lambda (x) (= 'marked_symbol (idx x 0))))
    (comb?                              (lambda (x) (= 'comb (idx x 0))))
    (prim_comb?                         (lambda (x) (= 'prim_comb (idx x 0))))
    (marked_env?                        (lambda (x) (= 'env (idx x 0))))

    (.hash                              (lambda (x) (idx x 1)))

    (.val                               (lambda (x) (idx x 2)))

    (.marked_array_is_val               (lambda (x) (idx x 2)))
    (.marked_array_is_attempted         (lambda (x) (idx x 3)))
    (.marked_array_needed_for_progress  (lambda (x) (idx x 4)))
    (.marked_array_values               (lambda (x) (idx x 5)))

    (.marked_symbol_needed_for_progress (lambda (x) (idx x 2)))
    (.marked_symbol_is_val              (lambda (x) (= nil (.marked_symbol_needed_for_progress x))))
    (.marked_symbol_value               (lambda (x) (idx x 3)))
    (.comb                              (lambda (x) (slice x 2 -1)))
    (.comb_id                           (lambda (x) (idx x 3)))
    (.comb_des                          (lambda (x) (idx x 4)))
    (.comb_env                          (lambda (x) (idx x 5)))
    (.comb_body                         (lambda (x) (idx x 8)))
    (.comb_wrap_level                   (lambda (x) (idx x 2)))
    (.prim_comb_sym                     (lambda (x) (idx x 3)))
    (.prim_comb_handler                 (lambda (x) (idx x 2)))
    (.prim_comb_wrap_level              (lambda (x) (idx x 4)))
    (.prim_comb_val_head_ok             (lambda (x) (idx x 5)))
    (.prim_comb                         (lambda (x) (slice x 2 -1)))

    (.marked_env                        (lambda (x) (slice x 2 -1)))
    (.marked_env_has_vals               (lambda (x) (idx x 2)))
    (.marked_env_needed_for_progress    (lambda (x) (idx x 3)))
    (.marked_env_idx                    (lambda (x) (idx x 4)))
    (.marked_env_upper                  (lambda (x) (idx (idx x 5) -1)))
    (.env_marked                        (lambda (x) (idx x 5)))
    (marked_env_real?                   (lambda (x) (= nil (idx (.marked_env_needed_for_progress x) 0))))
    (.any_comb_wrap_level               (lambda (x) (cond  ((prim_comb? x)   (.prim_comb_wrap_level x))
                                                           ((comb? x)        (.comb_wrap_level x))
                                                           (true             (error "bad .any_comb_level")))))
    ; The actual needed_for_progress values are either
    ; #t            - any eval will do something
    ; nil           - is a value, no eval will do anything
    ; (3 4 1...)    - list of env ids that would allow forward progress
    ; But these are paired with another list of hashes that if you're not inside
    ; of an evaluation of, then it could progress futher. These are all caused by
    ; the infinite recursion stopper.
    (needed_for_progress (rec-lambda needed_for_progress (x) (cond ((marked_array? x)       (.marked_array_needed_for_progress  x))
                                                                   ((marked_symbol? x)      (array (.marked_symbol_needed_for_progress x) nil nil))
                                                                   ((marked_env? x)         (.marked_env_needed_for_progress    x))
                                                                   ((comb? x)               (dlet ((id (.comb_id x))
                                                                                                   ((body_needed _hashes extra1) (needed_for_progress (.comb_body x)))
                                                                                                   ((se_needed   _hashes extra2) (needed_for_progress (.comb_env  x))))
                                                                                                (if (or (= true body_needed) (= true se_needed)) (array true nil nil)
                                                                                                        (array (array_union_without id body_needed se_needed)
                                                                                                               nil (array_union_without id extra1 extra2))
                                                                                                )))
                                                                   ((prim_comb? x)          (array nil nil nil))
                                                                   ((val? x)                (array nil nil nil))
                                                                   (true                    (error (str "what is this? in need for progress" x))))))
    (needed_for_progress_slim (lambda (x) (idx (needed_for_progress x) 0)))

    (hash_symbol      (lambda (progress_idxs s) (combine_hash (if (= true progress_idxs) 11 (foldl combine_hash 13 (map (lambda (x) (if (= true x) 13 (+ 1 x))) progress_idxs))) (hash_string (get-text s)))))
    (hash_array       (lambda (is_val attempted a) (foldl combine_hash (if is_val 17 (cond ((int? attempted) (combine_hash attempted 19))
                                                                                            (attempted       61)
                                                                                            (true            107))) (map .hash a))))

    (hash_env         (lambda (has_vals progress_idxs dbi arrs) (combine_hash (if has_vals 107 109)
                                                                (combine_hash (mif dbi (hash_num dbi) 59) (dlet (
                                                                ;(_ (begin (true_print "pre slice " (slice arrs 0 -2)) 0))
                                                                ;(_ (begin (true_print "about to do a fold " progress_idxs " and " (slice arrs 0 -2)) 0))
                                                                (inner_hash (foldl (dlambda (c (s v)) (combine_hash c (combine_hash (hash_symbol true s) (.hash v))))
                                                                                   (cond ((= nil progress_idxs)     23)
                                                                                         ((= true progress_idxs)    29)
                                                                                         (true                      (foldl combine_hash 31 progress_idxs)))
                                                                                   (slice arrs 0 -2)))
                                                                (end (idx arrs -1))
                                                                (end_hash (mif end (.hash end) 41))
                                                                                                         ) (combine_hash inner_hash end_hash))))))

    (hash_comb        (lambda (wrap_level env_id de? se variadic params body)
                                                                             (combine_hash 43
                                                                             (combine_hash wrap_level
                                                                             (combine_hash env_id
                                                                             (combine_hash (mif de? (hash_symbol true de?) 47)
                                                                             (combine_hash (.hash se)
                                                                             (combine_hash (hash_bool variadic)
                                                                             (combine_hash (foldl (lambda (c x) (combine_hash c (hash_symbol true x))) 53 params)
                                                                             (.hash body))))))))))

    (hash_prim_comb   (lambda (handler_fun real_or_name wrap_level val_head_ok) (combine_hash (combine_hash 59 (hash_symbol true real_or_name))
                                                                                              (combine_hash (if val_head_ok 89 97) wrap_level))))
    (hash_val         (lambda (x) (cond ((bool? x)     (hash_bool x))
                                        ((string? x)   (hash_string x))
                                        ((int? x)      (hash_num x))
                                        (true          (error (str "bad thing to hash_val " x))))))
    ; 113 127 131 137 139 149 151 157 163 167 173

    (marked_symbol    (lambda (progress_idxs x)                        (array 'marked_symbol    (hash_symbol progress_idxs x)                      progress_idxs x)))
    (marked_array     (lambda (is_val attempted resume_hashes x)       (dlet (
                                                                            ((sub_progress_idxs hashes extra) (foldl (dlambda ((a ahs aeei) (x xhs x_extra_env_ids))
                                                                                                    (array (cond ((or (= true a) (= true x)) true)
                                                                                                                 (true           (array_union a x)))
                                                                                                           (array_union ahs xhs)
                                                                                                           (array_union aeei x_extra_env_ids))
                                                                                                 ) (array (array) resume_hashes (array)) (map needed_for_progress x)))
                                                                            (progress_idxs (cond ((and (= nil sub_progress_idxs) (not is_val) (= true attempted))  nil)
                                                                                                 ((and (= nil sub_progress_idxs) (not is_val) (= false attempted)) true)
                                                                                                 ((and (= nil sub_progress_idxs) (not is_val) (int? attempted))    (array attempted))
                                                                                                 (true                                                             (if (int? attempted)
                                                                                                                                                                       (array_item_union sub_progress_idxs attempted)
                                                                                                                                                                       sub_progress_idxs))))
                                                                        ) (array 'marked_array  (hash_array is_val attempted x)                    is_val attempted (array progress_idxs hashes extra) x))))
    (marked_env       (lambda (has_vals de? de ue dbi arrs) (dlet (
                                  (de_entry (mif de? (array (array de? de)) (array)))
                                  (full_arrs (concat arrs de_entry (array ue)))
                                  ((progress_idxs1 _hashes extra1) (mif ue  (needed_for_progress ue) (array nil nil nil)))
                                  ((progress_idxs2 _hashes extra2) (mif de? (needed_for_progress de) (array nil nil nil)))
                                  (progress_idxs (array_union progress_idxs1 progress_idxs2))
                                  (extra (array_union extra1 extra2))
                                  (progress_idxs (if (not has_vals) (cons dbi progress_idxs) progress_idxs))
                                  (extra         (if (!= nil progress_idxs) (cons dbi extra) extra))
                                ) (array 'env              (hash_env has_vals progress_idxs dbi full_arrs)                  has_vals (array progress_idxs nil extra) dbi full_arrs))))


    (marked_val       (lambda (x)                                      (array 'val              (hash_val x)                                       x)))
    (marked_comb      (lambda (wrap_level env_id de? se variadic params body) (array 'comb      (hash_comb wrap_level env_id de? se variadic params body) wrap_level env_id de? se variadic params body)))
    (marked_prim_comb (lambda (handler_fun real_or_name wrap_level val_head_ok)    (array 'prim_comb        (hash_prim_comb handler_fun real_or_name wrap_level val_head_ok) handler_fun real_or_name wrap_level val_head_ok)))

    (with_wrap_level                    (lambda (x new_wrap) (cond  ((prim_comb? x)   (dlet (((handler_fun real_or_name wrap_level val_head_ok) (.prim_comb x)))
                                                                                             (marked_prim_comb handler_fun real_or_name new_wrap val_head_ok)))
                                                                    ((comb? x)        (dlet (((wrap_level env_id de? se variadic params body) (.comb x)))
                                                                                             (marked_comb new_wrap env_id de? se variadic params body)))
                                                                    (true             (error "bad with_wrap_level")))))






    (and_fold (foldl and true '(true true false true)))
    (monad (array 'write  1 (str "Hello from compiled code! " and_fold "\n") (vau (written code) (array 'exit 0))))

 ) monad)
 )
; end of all lets
))))))
; impl of let1
; this would be the macro style version (((
)) (vau de (s v b) (eval (array (array wrap (array vau (array s) b)) v) de)))
;)) (vau de (s v b) (eval (array (array vau (array s) b) (eval v de)) de)))
; impl of quote
)) (vau (x5) x5))
