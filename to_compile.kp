

((wrap (vau root_env (quote)
((wrap (vau (let1)


(let1 lambda (vau se (p b1) (wrap (eval (array vau p b1) se)))
(let1 current-env (vau de () de)
(let1 cons (lambda (h t) (concat (array h) t))
(let1 lapply (lambda (f1 p)     (eval (cons (unwrap f1) p) (current-env)))
(let1 vapply (lambda (f2 p ede) (eval (cons f2          p) ede))

(let1 Y (lambda (f3)
    ((lambda (x1) (x1 x1))
     (lambda (x2) (f3 (lambda (& y) (lapply (x2 x2) y))))))

(let1 vY (lambda (f)
    ((lambda (x3) (x3 x3))
     (lambda (x4) (f (vau de (& y) (vapply (x4 x4) y de))))))
(let1 let (vY (lambda (recurse) (vau de (vs b) (cond (= (len vs) 0) (eval b de)
                                                     true           (vapply let1 (array (idx vs 0) (idx vs 1) (array recurse (slice vs 2 -1) b)) de)))))


(array 'open  3 "test_self_out" (lambda (fd code)
(array 'write fd "wabcdefghijk"   (lambda (written code)
(array 'exit  written)))))

;(array 'write  1 "test_self_out2" (vau (written code) 1))


; end of all lets
)))))))
)

; impl of let1
; this would be the macro style version (((;)) (vau de (s v b) (eval (array (array wrap (array vau (array s) b)) v) de)))
)) (vau de (s v b) (eval (array (array vau (array s) b) (eval v de)) de)))
; impl of quote
)) (vau (x5) x5))



;(array 'write  1 "test_self_out2" (vau (written code) 1))
