import symbol:*
import tree:*
import vector:*
import stack:*
import map:*
import util:*
import string:*
import mem:*
import io:*
import importer:*
import ast_node:*

		/*Importer * importer;*/
		/*NodeTree<ASTData>* builtin_trans_unit; // the top scope for language level stuff*/
		/*std::map<std::string, std::vector<NodeTree<ASTData>*>> languageLevelReservedWords;*/
		/*std::map<std::string, std::vector<NodeTree<ASTData>*>> languageLevelOperators;*/
		/*std::map<NodeTree<ASTData>*, NodeTree<ASTData>*> this_map; // used to map implicit "this" variables to their type*/
		/*NodeTree<ASTData>* topScope; //maintained for templates that need to add themselves to the top scope no matter where they are instantiated*/
        /*int lambdaID = 0;*/
obj ast_transformation (Object) {
    fun construct(): *ast_transformation {
        return this
    }
    fun copy_construct(old: *ast_transformation) {
    }
    fun operator=(old: ref ast_transformation) {
        destruct()
        copy_construct(&old)
    }
    fun destruct() {
    }
    // first pass defines all type_defs (objects and aliases), ADTs, and top-level if/passthroughs
    fun first_pass(file_name: string, parse_tree: *tree<symbol>, importer: *importer): *ast_node {
        var translation_unit = ast_translation_unit_ptr()
        importer->register(file_name, parse_tree, translation_unit)
        parse_tree->children.for_each(fun(child: *tree<symbol>) {
            if (child->data.name == "type_def") {
                var name = concat_symbol_tree(get_node("identifier", child))
                var type_def_node = ast_type_def_ptr()
                translation_unit->translation_unit.children.add(type_def_node)
            }
        })
        return translation_unit
    }
}

fun concat_symbol_tree(node: *tree<symbol>): string {
    var str.construct(): string
    if (node->data.data != "no_value")
        str += node->data.data
    node->children.for_each(fun(child: *tree<symbol>) str += concat_symbol_tree(child);)
    return str
}
fun get_node(lookup: *char, parent: *tree<symbol>): *tree<symbol> {
    return get_node(string(lookup), parent)
}
fun get_node(lookup: string, parent: *tree<symbol>): *tree<symbol> {
    var results = get_nodes(lookup, parent)
    if (results.size > 1)
        println("too many results!")
    if (results.size)
        return results[0]
    return null<tree<symbol>>()
}
fun get_nodes(lookup: string, parent: *tree<symbol>): vector<*tree<symbol>> {
    return parent->children.filter(fun(node: *tree<symbol>):bool return node->data.name == lookup;)
}

