import string;
import vector;
import mem:*

fun println() : void {
    print("\n");
}

fun println<T>(toPrint: T) : void {
    print(toPrint)
    print("\n")
}

fun print<T>(toPrint: *T)
    print((toPrint) cast ulong)

ext fun printf(fmt_str: *char, to_print: *char): int
ext fun fflush(file: int): int
fun print(toPrint: *char) : void {
    printf("%s", toPrint)
    fflush(0)
}

fun print(toPrint: char) : void
    print(string::string(toPrint))

fun print(toPrint: string::string) : void {
    var charArr = toPrint.toCharArray()
    defer delete(charArr)
    print(charArr);
}

fun print(toPrint: bool): void {
    if (toPrint)
        print("true")
    else
        print("false")
	return;
}

ext fun sprintf(to_str: *char, format: *char, d: double)
fun print(toPrint: float)
    print((toPrint) cast double)

fun print(toPrint: double) {
    var int_str =  new<char>((#sizeof<double>) cast int)
    sprintf(int_str, "%f", toPrint)
    print(int_str)
    delete(int_str)
}
fun print<T>(toPrint: T): void 
    print(string::to_string(toPrint))
/*fun print(toPrint: ulong): void */
    /*print(string::to_string(toPrint))*/

// Ok, just some DEAD simple file io for now
ext fun fopen(path: *char, mode: *char): *void
ext fun fclose(file: *void): int
ext fun fprintf(file: *void, format: *char, data: *char): int
ext fun ftell(file: *void): long
ext fun fseek(file: *void, offset: long, whence: int): int
ext fun fread(ptr: *void, size: ulong, nmemb: ulong, file: *void): ulong
ext fun fwrite(ptr: *void, size: ulong, nmemb: ulong, file: *void): ulong
fun file_exists(path: string::string): bool {
    var char_path = path.toCharArray()
    defer delete(char_path)
    var fp = fopen(char_path, "r")
    if (fp) {
        fclose(fp)
        return true
	}
    return false
}
fun read_file(path: string::string): string::string {
    if (!file_exists(path))
        return string::string()
    var toRet.construct(read_file_binary(path)): string::string
    return toRet
}
fun write_file(path: string::string, data: string::string) {
    var char_path = path.toCharArray()
    defer delete(char_path)
    var char_data = data.toCharArray()
    defer delete(char_data)
    var fp = fopen(char_path, "w")
    fprintf(fp, "%s", char_data)
    fclose(fp)
}
fun read_file_binary(path: string::string): vector::vector<char> {
    var char_path = path.toCharArray()
    defer delete(char_path)
    var fp = fopen(char_path, "r")
    fseek(fp, (0) cast long, 2)// fseek(fp, 0L, SEEK_END)
    var size = ftell(fp)
    fseek(fp, (0) cast long, 0)//fseek(fp, 0L, SEEK_SET)
    var data = new<char>((size+1) cast int)
    var readSize = fread((data) cast *void, (1) cast ulong, (size) cast ulong, fp)
    fclose(fp)
    data[readSize] = 0
    var toRet.construct((size) cast int): vector::vector<char>
    for (var i = 0; i < size; i++;)
        toRet.add(data[i])
    delete(data)
    return toRet
}
fun write_file_binary(path: string::string, vdata: vector::vector<char>) {
    var char_path = path.toCharArray()
    defer delete(char_path)
    var data = vdata.getBackingMemory()
    var size = vdata.size
    var fp = fopen(char_path, "w")
    fwrite((data) cast *void, (1) cast ulong, (size) cast ulong, fp)
    fclose(fp)
}

fun BoldRed(): void{
  print("\033[1m\033[31m");
}

fun BoldGreen(): void{
  print("\033[1m\033[32m");
}

fun BoldYellow(): void{
  print("\033[1m\033[33m");
}

fun BoldBlue(): void{
  print("\033[1m\033[34m");
}

fun BoldMagenta(): void{
  print("\033[1m\033[35m");
}

fun BoldCyan(): void{
  print("\033[1m\033[36m");
}

fun Reset(): void{
  print("\033[0m");
}

