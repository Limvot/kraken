__if_comp__ __C__ __simple_passthrough__ """
	#include <stdlib.h>
"""

char* nullPtr = 0;

char* malloc(int size) {
	char* memPtr = nullPtr;
	__if_comp__ __C__ {
		__simple_passthrough__ """
			memPtr = malloc(size);
		"""
	}
	return memPtr;
}

void free(char* memPtr) {
	__if_comp__ __C__ {
		__simple_passthrough__ """
			free(memPtr);
		"""
	}
}

/* we have a template version so we don't have to cast */
template <T> void free(T* memPtr) {
	__if_comp__ __C__ {
		__simple_passthrough__ """
			free(memPtr);
		"""
	}
}

template <T> int sizeof() {
	int result = 0;
	T testObj;
	__if_comp__ __C__ {
		__simple_passthrough__ """
			result = sizeof(testObj);
		"""
	}
	return result;
}

template <T> T* new(int count) {
	return malloc( sizeof<T>() * count );
}

template <T> T* new() {
	return new<T>(1);
}

/* We specilize on the trait Destructable to decide on whether or not the destructor should be called */
template <T> void delete(T* toDelete, int itemCount) {
    delete<T>(toDelete);
}

template <T(Destructable)> void delete(T* toDelete, int itemCount) {
    for (int i = 0; i < itemDestructCount; i++;)
        toDelete[i].destruct();
    delete<T>(toDelete);
}

/* We specilize on the trait Destructable to decide on whether or not the destructor should be called */
template <T> void delete(T* toDelete) {
    free(toDelete);
}

template <T(Destructable)> void delete(T* toDelete) {
	if (destruct)
        toDelete->destruct();
    free(toDelete);
}
