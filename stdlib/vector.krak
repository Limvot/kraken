import mem:*;
import util:*;
import io:*;

obj vector<T> (Destructable) {
    var data: T*;
    var size: int;
    var available: int;

    fun construct(): vector<T>* {
        size = 0;
        available = 8;
        data = new<T>(8);
        return this;
    }

    fun construct(newSize: int): vector<T>*{
        size = newSize;
        available = newSize;

        data = new<T>(newSize);
        return this;
    }

    fun copy_construct(old: vector<T>*): void {
        construct(old->size)
        for (var i = 0; i < size; i++;)
            set(i, old->get(i))
    }

    fun destruct(): void {
        if (data)
            delete<T>(data);
        data = 0
    }

    fun operator=(other:vector<T>):void {
        resize(other.size)
        for (var i = 0; i < other.size; i++;)
            set(i, other.get(i))
    }

    fun operator+(other:vector<T>):vector<T> {
        var newVec.construct(size + other.size):vector<T>
        for (var i = 0; i < size; i++;)
            newVec.set(i, get(i))
        for (var i = 0; i < other.size; i++;)
            newVec.set(i+size, other.get(i))
        return newVec
    }

    fun operator+=(other:vector<T>):void {
        for (var i = 0; i < other.size; i++;)
            addEnd(other.get(i))
    }

    fun clone(): vector<T> {
        var newVec.construct(size): vector<T>
        for (var i = 0; i < size; i++;)
            newVec.set(i, data[i])
        return newVec
    }

    fun resize(newSize: int): bool {
        var newData: T* = new<T>(newSize);
        if (!newData)
            return false;
        for (var i: int = 0; i < lesser<int>(size, newSize); i++;)
            newData[i] = data[i];
        delete<T>(data, 0);
        data = newData;
        available = newSize;
        size = lesser(size, newSize)
        return true;
    }

    fun at(index: int): T {
        return get(index);
    }

    fun get(index: int): T {
        if (index < 0 || index >= size) {
            println("Vector access out of bounds! Retuning 0th element as sanest option");
            print("Vector tried to access element: ");
            println(index);
            print("Max Index of vector: ");
            println(size-1);
            return data[0];
        }
        return data[index];
    }

    fun getBackingMemory(): T* { return data; }

    fun set(index: int, dataIn: T): void {
        if (index < 0 || index  >= size)
            return;
        data[index] = dataIn;
    }
    fun addEnd(dataIn: T): void {
        size++;
        if (size >= available)
            resize(size*2);
        data[size-1] = dataIn;
    }
    fun do(func: fun(T):void):void {
        for (var i = 0; i < size; i++;)
            func(data[i])
    }
    fun in_place(func: fun(T):T):void {
        for (var i = 0; i < size; i++;)
            data[i] = func(data[i])
    }
    fun map<U>(func: fun(T):U):vector<U> {
        var newVec.construct(size): vector<U>
        for (var i = 0; i < size; i++;)
            newVec.set(i, func(data[i]))
        return newVec
    }
};

