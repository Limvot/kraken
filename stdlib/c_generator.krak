import io:*
import mem:*
import map:*
import string:*
import util:*
import tree:*
import symbol:*
import ast_nodes:*


obj c_generator (Object) {
    fun construct(): *c_generator {
        return this
    }
    fun copy_construct(old: *c_generator) {
    }
    fun operator=(other: ref c_generator) {
        destruct()
        copy_construct(&other)
    }
    fun destruct() {
    }
    fun generate_c(name_ast_map: map<string, pair<*tree<symbol>,*ast_node>>): pair<string,string> {
        var linker_string:string = ""
        var prequal: string = "#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n"
        var plain_typedefs: string = ""
        var top_level_c_passthrough: string = ""
        var variable_extern_declarations: string = ""
        var structs: string = ""
        var function_typedef_string_pre: string = ""
        var function_typedef_string: string = ""
        var function_prototypes: string = "\n/**Function Prototypes**/\n"
        var function_definitions: string = "\n/**Function Definitions**/\n"
        var variable_declarations: string = "\n/**Variable Declarations**/\n"


        // poset generation into structs string
        // iterate through asts
        name_ast_map.for_each(fun(name: string, tree_pair: pair<*tree<symbol>,*ast_node>) {
            // iterate through children for each ast
            // assert translation_unit?
            tree_pair.second->translation_unit.children.for_each(fun(child: *ast_node) {
                match (*child) {
                    // should really check the genrator
                    ast_node::if_comp(backing) {
                        if (is_simple_passthrough(backing.statement->statement.child))
                            top_level_c_passthrough += generate_simple_passthrough(backing.statement->statement.child)
                    }
                    ast_node::simple_passthrough(backing) top_level_c_passthrough += generate_simple_passthrough(child)
                    ast_node::function(backing) {
                        // make sure not a template
                        // or a passthrough
                        // check for and add to parameters if a closure
                        var parameter_types = string()
                        var parameters = string()
                        // also add in name decoration
                        backing.parameters.for_each(fun(parameter: *ast_node) {
                            if (parameter_types != "") { parameter_types += ", "; parameters += ", ";}
                            parameter_types += type_to_c(parameter->identifier.type)
                            parameters += type_to_c(parameter->identifier.type) + " " + parameter->identifier.name
                        })
                        function_prototypes += type_to_c(backing.type->return_type) + " " + backing.name + "(" + parameter_types + ");\n"

                        // add parameters to destructor thingy (for returns)? Or should that be a different pass?
                        function_definitions += type_to_c(backing.type->return_type) + " " + backing.name + "(" + parameters + ") {\n" + generate_statement(backing.body_statement)
                        // emit parameter destructors?
                        function_definitions += "}\n"
                    }
                }
            })
        })

        return make_pair(prequal+plain_typedefs+top_level_c_passthrough+variable_extern_declarations+structs+function_typedef_string_pre+function_typedef_string+function_prototypes+variable_declarations+function_definitions + "\n", linker_string)
    }
    fun generate_simple_passthrough(node: *ast_node): string {
        // deal with all the passthrough params
        return node->simple_passthrough.passthrough_str
    }
    fun generate_statement(node: *ast_node): string return generate(node->statement.child) + ";\n";
    fun generate_return_statement(node: *ast_node): string return string("return ") + generate(node->return_statement.return_value);
    fun generate_value(node: *ast_node): string return node->value.string_value;
    fun generate_code_block(node: *ast_node): string {
        var to_ret = string("{\n")
        node->code_block.children.for_each(fun(child: *ast_node) to_ret += generate(child);)
        return to_ret + "}"
    }

    // for now, anyway
    fun generate(node: *ast_node): string {
        if (!node) return string("/*NULL*/")
        match (*node) {
            ast_node::simple_passthrough(backing) return generate_simple_passthrough(node)
            ast_node::statement(backing) return generate_statement(node)
            ast_node::code_block(backing) return generate_code_block(node)
            ast_node::return_statement(backing) return generate_return_statement(node)
            ast_node::value(backing) return generate_value(node)
        }
        return string("/* COULD NOT GENERATE */")
    }
    fun type_to_c(type: *type): string {
        var indirection = string()
        for (var i = 0; i < type->indirection; i++;) indirection += "*"
        match (type->base) {
            base_type::none() return string("none") + indirection
            base_type::template() return string("template") + indirection
            base_type::template_type() return string("template_type") + indirection
            base_type::void_return() return string("void") + indirection
            base_type::boolean() return string("bool") + indirection
            base_type::character() return string("char") + indirection
            base_type::integer() return string("int") + indirection
            base_type::floating() return string("float") + indirection
            base_type::double_precision() return string("double") + indirection
            base_type::function() {
                var temp = indirection + string("function: (")
                type->parameter_types.for_each(fun(parameter_type: *type) temp += parameter_type->to_string() + " ";)
                return temp + ")" + type->return_type->to_string()
            }
        }
        return string("impossible type") + indirection
    }
}


