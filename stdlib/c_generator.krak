import io:*
import mem:*
import map:*
import stack:*
import string:*
import util:*
import tree:*
import symbol:*
import ast_nodes:*
import poset:*

fun code_triple(): code_triple return code_triple(string(), string(), string());
fun code_triple(only: *char): code_triple return code_triple(string(), string(only), string());
fun code_triple(only: string): code_triple return code_triple(string(), only, string());
fun code_triple(first: string, second: string, third: string): code_triple {
    var to_ret.construct(first, second, third): code_triple
    return to_ret
}
obj code_triple (Object) {
    var pre: string
    var value: string
    var post: string
    fun construct(first: string, second: string, third: string): *code_triple {
        pre.copy_construct(&first)
        value.copy_construct(&second)
        post.copy_construct(&third)
        return this
    }
    fun copy_construct(old: *code_triple) {
        pre.copy_construct(&old->pre)
        value.copy_construct(&old->value)
        post.copy_construct(&old->post)
    }
    fun operator=(other: code_triple) {
        destruct()
        copy_construct(&other)
    }
    fun destruct() {
        pre.destruct()
        value.destruct()
        post.destruct()
    }
    fun operator==(other: code_triple): bool return pre == other.pre && value == other.value && post == other.value;
    fun operator==(other: string): bool return (pre + value + post) == other;
    fun operator==(other: *char): bool return (pre + value + post) == other;
    fun operator!=(other: code_triple): bool return pre != other.pre || value != other.value || post != other.value;
    fun operator!=(other: string): bool return (pre + value + post) != other;
    fun operator!=(other: *char): bool return (pre + value + post) != other;
    fun operator+(other: code_triple): code_triple {
        return code_triple(pre+other.pre, value+other.value, other.post+post);
    }
    fun operator+(other: string): code_triple {
        return code_triple(pre, value+other, post);
    }
    fun operator+(other: *char): code_triple {
        return code_triple(pre, value + other, post);
    }
    fun operator+=(other: string) {
        value += other
    }
    fun operator+=(other: *char) {
        value += other
    }
    fun operator+=(other: code_triple) {
        pre += other.pre
        value += other.value
        post += other.post
    }
    fun one_string():string {
        return pre+value+post
    }
}

obj c_generator (Object) {
    fun construct(): *c_generator {
        return this
    }
    fun copy_construct(old: *c_generator) {
    }
    fun operator=(other: ref c_generator) {
        destruct()
        copy_construct(&other)
    }
    fun destruct() {
    }
    fun generate_c(name_ast_map: map<string, pair<*tree<symbol>,*ast_node>>): pair<string,string> {
        var linker_string:string = ""
        var prequal: string = "#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n"
        var plain_typedefs: string = "\n/**Plain Typedefs**/\n"
        var top_level_c_passthrough: string = ""
        var variable_extern_declarations: string = ""
        var structs: string = "\n/**Type Structs**/\n"
        var function_typedef_string_pre: string = ""
        var function_typedef_string: string = ""
        var function_prototypes: string = "\n/**Function Prototypes**/\n"
        var function_definitions: string = "\n/**Function Definitions**/\n"
        var variable_declarations: string = "\n/**Variable Declarations**/\n"

        // moved out from below so that it can be used for methods as well as regular functions (and eventually lambdas...)
        var generate_function_definition = fun(child: *ast_node, enclosing_object: *ast_node) {
            var backing = child->function

            var parameter_types = string()
            var parameters = string()
            if (enclosing_object) {
                parameter_types = type_to_c(enclosing_object->type_def.self_type) + "*"
                parameters = type_to_c(enclosing_object->type_def.self_type) + "* this"
            }
            var decorated_name = generate_function(child).one_string()
            // also add in name decoration
            backing.parameters.for_each(fun(parameter: *ast_node) {
                if (parameter_types != "") { parameter_types += ", "; parameters += ", ";}
                parameter_types += type_to_c(parameter->identifier.type)
                parameters += type_to_c(parameter->identifier.type) + " " + parameter->identifier.name
            })
            function_prototypes += type_to_c(backing.type->return_type) + " " + decorated_name + "(" + parameter_types + ");\n"

            // add parameters to destructor thingy (for returns)? Or should that be a different pass?
            // stack-stack thing // this could be a stack of strings too, maybe
            // start out with one stack on the stack
            var defer_stack = stack<pair<bool,stack<*ast_node>>>(make_pair(false, stack<*ast_node>()))
            function_definitions += type_to_c(backing.type->return_type) + " " + decorated_name + "(" + parameters + ") {\n" + generate_statement(backing.body_statement, enclosing_object, &defer_stack).one_string()
            // emit parameter destructors?
            function_definitions += "}\n"
        }

        var type_poset = poset<*ast_node>()
        // iterate through asts
        name_ast_map.for_each(fun(name: string, tree_pair: pair<*tree<symbol>,*ast_node>) {
            // iterate through children for each ast
            // assert translation_unit?
            tree_pair.second->translation_unit.children.for_each(fun(child: *ast_node) {
                match (*child) {
                    // should really check the genrator
                    ast_node::if_comp(backing) {
                        if (is_simple_passthrough(backing.statement->statement.child))
                            top_level_c_passthrough += generate_simple_passthrough(backing.statement->statement.child)
                    }
                    ast_node::simple_passthrough(backing) top_level_c_passthrough += generate_simple_passthrough(child)
                    ast_node::declaration_statement(backing) variable_declarations += generate_declaration_statement(child, null<ast_node>(), null<stack<pair<bool,stack<*ast_node>>>>()).one_string() + ";\n"
                    ast_node::function(backing) {
                        // make sure not a template
                        // or a passthrough
                        // check for and add to parameters if a closure
                        generate_function_definition(child, null<ast_node>())
                    }
                    ast_node::type_def(backing) {
                        type_poset.add_vertex(child)
                    }
                }
            })
        })
        type_poset.get_sorted().for_each(fun(vert: *ast_node) {
            plain_typedefs += string("typedef struct ") + vert->type_def.name + "_dummy " + vert->type_def.name + ";\n"
            structs += string("struct ") + vert->type_def.name + "_dummy {\n"
            vert->type_def.variables.for_each(fun(variable_declaration: *ast_node) structs += generate_declaration_statement(variable_declaration, null<ast_node>(), null<stack<pair<bool,stack<*ast_node>>>>()).one_string() + ";\n";)
            structs += "};\n"
            // generate the methods
            vert->type_def.methods.for_each(fun(method: *ast_node) generate_function_definition(method, vert);)
        })

        return make_pair(prequal+plain_typedefs+top_level_c_passthrough+variable_extern_declarations+structs+function_typedef_string_pre+function_typedef_string+function_prototypes+variable_declarations+function_definitions + "\n", linker_string)
    }
    fun generate_if_comp(node: *ast_node): code_triple {
        if (node->if_comp.wanted_generator == "__C__")
            return generate(node->if_comp.statement, null<ast_node>(), null<stack<pair<bool,stack<*ast_node>>>>())
        return code_triple()
    }
    fun generate_simple_passthrough(node: *ast_node): string {
        // deal with all the passthrough params
        return node->simple_passthrough.passthrough_str
    }
    fun generate_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple return generate(node->statement.child, enclosing_object, defer_stack) + ";\n";
    fun generate_declaration_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        // add destruct to defer_stac
        var identifier = node->declaration_statement.identifier
        var to_ret = code_triple() + type_to_c(identifier->identifier.type) + " " + identifier->identifier.name
        if (node->declaration_statement.expression) to_ret += code_triple(" = ") + generate(node->declaration_statement.expression, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
        if (node->declaration_statement.init_method_call) to_ret += code_triple(";\n") + generate(node->declaration_statement.init_method_call, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
        return to_ret
    }
    fun generate_assignment_statement(node: *ast_node, enclosing_object: *ast_node): code_triple {
        return generate(node->assignment_statement.to, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + " = " + generate(node->assignment_statement.from, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
    }
    fun generate_if_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        var if_str = code_triple("if (") + generate(node->if_statement.condition, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + ") {\n" + generate(node->if_statement.then_part, enclosing_object, defer_stack) + "}"
        if (node->if_statement.else_part)
            if_str += code_triple(" else {\n") + generate(node->if_statement.else_part, enclosing_object, defer_stack) + "}"
        return if_str + "\n"
    }
    fun generate_while_loop(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        // stick another stack on
        defer_stack->push(make_pair(true, stack<*ast_node>()))
        var to_ret = code_triple("while (") + generate(node->while_loop.condition, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string() + ") {\n" + generate(node->while_loop.statement, enclosing_object, defer_stack).one_string()
        to_ret += generate_from_defer_stack(defer_stack, 1, enclosing_object)
        defer_stack->pop()
        to_ret += "}\n"
        return to_ret
    }
    fun generate_for_loop(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        // stick another stack on
        defer_stack->push(make_pair(true, stack<*ast_node>()))
        // gotta take off last semicolon
        var to_ret = code_triple("for (") + generate(node->for_loop.init, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string() + " " + generate(node->for_loop.condition, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string() + "; " +
            generate(node->for_loop.update, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string().slice(0,-3) +
            ") {\n" + generate(node->for_loop.body, enclosing_object, defer_stack).one_string()
        to_ret += generate_from_defer_stack(defer_stack, 1, enclosing_object).one_string()
        defer_stack->pop()
        to_ret += "}\n"
        return to_ret
    }
    fun generate_identifier(node: *ast_node, enclosing_object: *ast_node): code_triple {
        if (enclosing_object && get_ast_scope(enclosing_object)->contains_key(node->identifier.name))
            return code_triple("(this->") + node->identifier.name + ")"
        return code_triple(node->identifier.name)
    }
    fun generate_return_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        // generate all in stack by passing -1
        var to_ret = generate_from_defer_stack(defer_stack, -1, enclosing_object)
        to_ret += code_triple("return ") + generate(node->return_statement.return_value, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
        return to_ret
    }
    fun generate_branching_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        // -2 means generate up through loop
        var to_ret = generate_from_defer_stack(defer_stack, -2, enclosing_object)
        match(node->branching_statement.b_type) {
            branching_type::break_stmt() return to_ret + string("break")
            branching_type::continue_stmt() return to_ret + string("continue")
        }
    }
    fun generate_from_defer_stack(defer_stack: *stack<pair<bool,stack<*ast_node>>>, num: int, enclosing_object: *ast_node): code_triple {
        var to_ret = code_triple()
        if (num == -1)
            num = defer_stack->size()
        if (num == -2) {
            num = 1
            for (var i = 0; i < defer_stack->size(); i++;)
                if (defer_stack->from_top(i).first)
                    break
                else
                    num++
        }
        for (var i = 0; i < num; i++;)
            defer_stack->from_top(i).second.for_each(fun(node: *ast_node) to_ret += generate(node, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>());)
        return to_ret
    }
    fun generate_defer_statement(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        defer_stack->top().second.push(node->defer_statement.statement)
        return code_triple("/*defer wanna know what*/")
    }
    fun generate_value(node: *ast_node): code_triple return code_triple(node->value.string_value);
    fun generate_code_block(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        var to_ret = code_triple("{\n")
        // stick another stack on
        defer_stack->push(make_pair(false, stack<*ast_node>()))
        node->code_block.children.for_each(fun(child: *ast_node) to_ret += generate(child, enclosing_object, defer_stack).one_string();)
        to_ret += generate_from_defer_stack(defer_stack, 1, enclosing_object)
        defer_stack->pop()
        return to_ret + "}"
    }
    // this generates the function as a value, not the actual function
    fun generate_function(node: *ast_node): code_triple {
        var str = code_triple(node->function.name)
        node->function.parameters.for_each(fun(param: *ast_node) str += string("_") + type_decoration(param->identifier.type);)
        return str
    }
    fun generate_function_call(node: *ast_node, enclosing_object: *ast_node): code_triple {
        var func_name = string()
        var call_string = code_triple()

        // handle the obj.method() style of method call
        var dot_style_method_call = is_function_call(node->function_call.func) &&
            is_function(node->function_call.func->function_call.func) &&
            (node->function_call.func->function_call.func->function.name == "->" || node->function_call.func->function_call.func->function.name == ".") &&
            is_function(node->function_call.func->function_call.parameters[1]) &&
            is_type_def(get_ast_scope(node->function_call.func->function_call.parameters[1])->get(string("~enclosing_scope"))[0])

        if (dot_style_method_call) {
            func_name = generate(node->function_call.func->function_call.parameters[1], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string()
            // don't add & if it was ->
            if (node->function_call.func->function_call.func->function.name == ".")
                call_string += "&"
            call_string += generate(node->function_call.func->function_call.parameters[0], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
        } else { // regular style function name
            func_name = generate(node->function_call.func, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()).one_string()
        }
        // handle method call from inside method of same object
        if (!dot_style_method_call && enclosing_object && get_ast_scope(enclosing_object)->contains_key(func_name))
            call_string += "this"


        var parameters = node->function_call.parameters
        if ( parameters.size == 2 && (func_name == "+" || func_name == "-" || func_name == "*" || func_name == "/" || func_name == "||"
            || func_name == "&&" || func_name == "<" || func_name == ">" || func_name == "<=" || func_name == ">="
            || func_name == "==" || func_name == "%"
        ))
            return code_triple("(") + generate(parameters[0], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + func_name + generate(parameters[1], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + string(")")
        // don't propegate enclosing function down right of access
        if (func_name == "." || func_name == "->")
            return code_triple("(") + generate(parameters[0], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + func_name + generate(parameters[1], null<ast_node>(), null<stack<pair<bool,stack<*ast_node>>>>()) + string(")")
        // the post ones need to be post-ed specifically, and take the p off
        if (func_name == "++p" || func_name == "--p")
            return code_triple("(") + generate(parameters[0], enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>()) + ")" + func_name.slice(0,-2)

        // regular parameter generation
        parameters.for_each(fun(param: *ast_node) {
            if (call_string != "")
                call_string += ", "
            call_string += generate(param, enclosing_object, null<stack<pair<bool,stack<*ast_node>>>>())
        })
        return code_triple() + func_name + "(" + call_string + ")"
    }

    // for now, anyway
    fun generate(node: *ast_node, enclosing_object: *ast_node, defer_stack: *stack<pair<bool,stack<*ast_node>>>): code_triple {
        if (!node) return code_triple("/*NULL*/")
        match (*node) {
            ast_node::if_comp(backing) return generate_if_comp(node)
            ast_node::simple_passthrough(backing) return code_triple() + generate_simple_passthrough(node)
            ast_node::statement(backing) return generate_statement(node, enclosing_object, defer_stack)
            ast_node::declaration_statement(backing) return generate_declaration_statement(node, enclosing_object, defer_stack)
            ast_node::assignment_statement(backing) return generate_assignment_statement(node, enclosing_object)
            ast_node::if_statement(backing) return generate_if_statement(node, enclosing_object, defer_stack)
            ast_node::while_loop(backing) return generate_while_loop(node, enclosing_object, defer_stack)
            ast_node::for_loop(backing) return generate_for_loop(node, enclosing_object, defer_stack)
            ast_node::function(backing) return generate_function(node)
            ast_node::function_call(backing) return generate_function_call(node, enclosing_object)
            ast_node::code_block(backing) return generate_code_block(node, enclosing_object, defer_stack)
            ast_node::return_statement(backing) return generate_return_statement(node, enclosing_object, defer_stack)
            ast_node::branching_statement(backing) return generate_branching_statement(node, enclosing_object, defer_stack)
            ast_node::defer_statement(backing) return generate_defer_statement(node, enclosing_object, defer_stack)
            ast_node::value(backing) return generate_value(node)
            ast_node::identifier(backing) return generate_identifier(node, enclosing_object)
        }
        return code_triple("/* COULD NOT GENERATE */")
    }
    fun type_decoration(type: *type): string {
        var indirection = string()
        for (var i = 0; i < type->indirection; i++;) indirection += "p"
        if (type->indirection) indirection += "_"
        match (type->base) {
            base_type::none() return indirection + string("none")
            base_type::template() return indirection + string("template")
            base_type::template_type() return indirection + string("template_type")
            base_type::void_return() return indirection + string("void")
            base_type::boolean() return indirection + string("bool")
            base_type::character() return indirection + string("char")
            base_type::integer() return indirection + string("int")
            base_type::floating() return indirection + string("float")
            base_type::double_precision() return indirection + string("double")
            base_type::object() {
                return type->type_def->type_def.name
            }
            base_type::function() {
                var temp = indirection + string("function_")
                type->parameter_types.for_each(fun(parameter_type: *type) temp += type_decoration(parameter_type) + "_";)
                return indirection + temp + "_" + type_decoration(type->return_type)
            }
        }
        return string("impossible type") + indirection
    }
    fun type_to_c(type: *type): string {
        var indirection = string()
        for (var i = 0; i < type->indirection; i++;) indirection += "*"
        match (type->base) {
            base_type::none() return string("none") + indirection
            base_type::template() return string("template") + indirection
            base_type::template_type() return string("template_type") + indirection
            base_type::void_return() return string("void") + indirection
            base_type::boolean() return string("bool") + indirection
            base_type::character() return string("char") + indirection
            base_type::integer() return string("int") + indirection
            base_type::floating() return string("float") + indirection
            base_type::double_precision() return string("double") + indirection
            base_type::object() {
                return type->type_def->type_def.name + indirection
            }
            base_type::function() {
                var temp = indirection + string("function: (")
                type->parameter_types.for_each(fun(parameter_type: *type) temp += parameter_type->to_string() + " ";)
                return temp + ")" + type->return_type->to_string()
            }
        }
        return string("impossible type") + indirection
    }
}


