import tree:*
import vector:*
import stack:*
import map:*
import util:*
import string:*
import mem:*
import io:*


adt ast_node {
    translation_unit: translation_unit,
    import: import,
    identifier: identifier,
    type_def: type_def,
    adt_def: adt_def,
    function: function,
    code_block: code_block,
    typed_parameter: typed_parameter,
    expression: expression,
    boolean_expression: boolean_expression,
    statement: statement,
    if_statement: if_statement,
    match_statement: match_statement,
    case_statement: case_statement,
    while_loop: while_loop,
    for_loop: for_loop,
    return_statement: return_statement,
    break_statement: break_statement,
    continue_statement: continue_statement,
    defer_statement: defer_statement,
    assignment_statement: assignment_statement,
    declaration_statement: declaration_statement,
    if_comp: if_comp,
    simple_passthrough: simple_passthrough,
    passthrough_params: passthrough_params,
    in_passthrough_params: in_passthrough_params,
    out_passthrough_params: out_passthrough_params,
    opt_string: opt_string,
    param_assign: param_assign,
    function_call: function_call,
    value: value
}
/*
total:
		ASTType type;
		Type* valueType;
		Symbol symbol;
		std::map<std::string, std::vector<NodeTree<ASTData>*>> scope;
        std::set<NodeTree<ASTData>*> closedVariables;
*/
fun ast_node_ptr(node: ast_node): *ast_node {
    var to_ret = new<ast_node>()
    to_ret->copy_construct(&node)
    return to_ret
}
fun ast_translation_unit_ptr(name: string): *ast_node {
    var obj_var.construct(name): translation_unit 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::translation_unit(obj_var))
    return ptr
}
obj translation_unit (Object) {
    var children: vector<*ast_node>
    var name: string
    fun construct(nameIn: string): *translation_unit  {
        children.construct()
        name.copy_construct(&nameIn)
        return this
    }
    fun copy_construct(old: *translation_unit) {
        children.copy_construct(&old->children)
        name.copy_construct(&old->name)
    }
    fun destruct() {
        children.destruct()
        name.destruct()
    }
    fun operator=(other: ref translation_unit) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref translation_unit): bool {
        return children == other.children && name == other.name
    }
}
fun ast_import_ptr(name: string): *ast_node {
    var to_ret.construct(name): import 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::import(to_ret))
    return ptr
}
obj import (Object) {
    var children: vector<*ast_node>
    var name: string
    fun construct(nameIn: string): *import  {
        children.construct()
        name.copy_construct(&nameIn)
        return this
    }
    fun copy_construct(old: *import) {
        children.copy_construct(&old->children)
        name.copy_construct(&old->name)
    }
    fun destruct() {
        children.destruct()
        name.destruct()
    }
    fun operator=(other: ref import) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref import): bool {
        return children == other.children && name == other.name
    }
}
fun ast_identifier_ptr(): *ast_node {
    var to_ret.construct(): identifier 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::identifier(to_ret))
    return ptr
}
obj identifier (Object) {
    fun construct(): *identifier {
        return this
    }
    fun copy_construct(old: *identifier) {
    }
    fun destruct() {
    }
    fun operator=(other: ref identifier) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref identifier): bool {
        return true
    }
}
fun ast_type_def_ptr(name: string): *ast_node {
    var to_ret.construct(name): type_def 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::type_def(to_ret))
    return ptr
}
obj type_def (Object) {
    var name: string
    fun construct(nameIn: string): *type_def  {
        name.copy_construct(&nameIn)
        return this
    }
    fun copy_construct(old: *type_def) {
        name.copy_construct(&old->name)
    }
    fun destruct() {
        name.destruct()
    }
    fun operator=(other: ref type_def) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref type_def): bool {
        return name == other.name
    }
}
fun ast_adt_def_ptr(name: string): *ast_node {
    var to_ret.construct(name): adt_def 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::adt_def(to_ret))
    return ptr
}
obj adt_def (Object) {
    var name: string
    fun construct(nameIn: string): *adt_def  {
        name.copy_construct(&nameIn)
        return this
    }
    fun copy_construct(old: *adt_def) {
        name.copy_construct(&old->name)
    }
    fun destruct() {
        name.destruct()
    }
    fun operator=(other: ref adt_def) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref adt_def): bool {
        return name == other.name
    }
}
fun ast_function_ptr(): *ast_node {
    var to_ret.construct(): function 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::function(to_ret))
    return ptr
}
obj function (Object) {
    fun construct(): *function  {
        return this
    }
    fun copy_construct(old: *function) {
    }
    fun destruct() {
    }
    fun operator=(other: ref function) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref function): bool {
        return true
    }
}
fun ast_code_block_ptr(): *ast_node {
    var to_ret.construct(): code_block 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::code_block(to_ret))
    return ptr
}
obj code_block (Object) {
    fun construct(): *code_block {
        return this
    }
    fun copy_construct(old: *code_block) {
    }
    fun destruct() {
    }
    fun operator=(other: ref code_block) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref code_block): bool {
        return true
    }
}
fun ast_typed_parameter_ptr(): *ast_node {
    var to_ret.construct(): typed_parameter 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::typed_parameter(to_ret))
    return ptr
}
obj typed_parameter (Object) {
    fun construct(): *typed_parameter {
        return this
    }
    fun copy_construct(old: *typed_parameter) {
    }
    fun destruct() {
    }
    fun operator=(other: ref typed_parameter) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref typed_parameter): bool {
        return true
    }
}
fun ast_expression_ptr(): *ast_node {
    var to_ret.construct(): expression 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::expression(to_ret))
    return ptr
}
obj expression (Object) {
    fun construct(): *expression  {
        return this
    }
    fun copy_construct(old: *expression) {
    }
    fun destruct() {
    }
    fun operator=(other: ref expression) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref expression): bool {
        return true
    }
}
fun ast_boolean_expression_ptr(): *ast_node {
    var to_ret.construct(): boolean_expression 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::boolean_expression(to_ret))
    return ptr
}
obj boolean_expression (Object) {
    fun construct(): *boolean_expression  {
        return this
    }
    fun copy_construct(old: *boolean_expression) {
    }
    fun destruct() {
    }
    fun operator=(other: ref boolean_expression) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref boolean_expression): bool {
        return true
    }
}
fun ast_statement_ptr(): *ast_node {
    var to_ret.construct(): statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::statement(to_ret))
    return ptr
}
obj statement (Object) {
    fun construct(): *statement  {
        return this
    }
    fun copy_construct(old: *statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref statement): bool {
        return true
    }
}
fun ast_if_statement_ptr(): *ast_node {
    var to_ret.construct(): if_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::if_statement(to_ret))
    return ptr
}
obj if_statement (Object) {
    fun construct(): *if_statement  {
        return this
    }
    fun copy_construct(old: *if_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref if_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref if_statement): bool {
        return true
    }
}
fun ast_match_statement_ptr(): *ast_node {
    var to_ret.construct(): match_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::match_statement(to_ret))
    return ptr
}
obj match_statement (Object) {
    fun construct(): *match_statement  {
        return this
    }
    fun copy_construct(old: *match_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref match_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref match_statement): bool {
        return true
    }
}
fun ast_case_statement_ptr(): *ast_node {
    var to_ret.construct(): case_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::case_statement(to_ret))
    return ptr
}
obj case_statement (Object) {
    fun construct(): *case_statement  {
        return this
    }
    fun copy_construct(old: *case_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref case_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref case_statement): bool {
        return true
    }
}
fun ast_while_loop_ptr(): *ast_node {
    var to_ret.construct(): while_loop 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::while_loop(to_ret))
    return ptr
}
obj while_loop (Object) {
    fun construct(): *while_loop  {
        return this
    }
    fun copy_construct(old: *while_loop) {
    }
    fun destruct() {
    }
    fun operator=(other: ref while_loop) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref while_loop): bool {
        return true
    }
}
fun ast_for_loop_ptr(): *ast_node {
    var to_ret.construct(): for_loop 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::for_loop(to_ret))
    return ptr
}
obj for_loop (Object) {
    fun construct(): *for_loop  {
        return this
    }
    fun copy_construct(old: *for_loop) {
    }
    fun destruct() {
    }
    fun operator=(other: ref for_loop) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref for_loop): bool {
        return true
    }
}
fun ast_return_statement_ptr(): *ast_node {
    var to_ret.construct(): return_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::return_statement(to_ret))
    return ptr
}
obj return_statement (Object) {
    fun construct(): *return_statement  {
        return this
    }
    fun copy_construct(old: *return_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref return_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref return_statement): bool {
        return true
    }
}
fun ast_break_statement_ptr(): *ast_node {
    var to_ret.construct(): break_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::break_statement(to_ret))
    return ptr
}
obj break_statement (Object) {
    fun construct(): *break_statement  {
        return this
    }
    fun copy_construct(old: *break_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref break_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref break_statement): bool {
        return true
    }
}
fun ast_continue_statement_ptr(): *ast_node {
    var to_ret.construct(): continue_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::continue_statement(to_ret))
    return ptr
}
obj continue_statement (Object) {
    fun construct(): *continue_statement  {
        return this
    }
    fun copy_construct(old: *continue_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref continue_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref continue_statement): bool {
        return true
    }
}
fun ast_defer_statement_ptr(): *ast_node {
    var to_ret.construct(): defer_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::defer_statement(to_ret))
    return ptr
}
obj defer_statement (Object) {
    fun construct(): *defer_statement  {
        return this
    }
    fun copy_construct(old: *defer_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref defer_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref defer_statement): bool {
        return true
    }
}
fun ast_assignment_statement_ptr(): *ast_node {
    var to_ret.construct(): assignment_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::assignment_statement(to_ret))
    return ptr
}
obj assignment_statement (Object) {
    fun construct(): *assignment_statement  {
        return this
    }
    fun copy_construct(old: *assignment_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref assignment_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref assignment_statement): bool {
        return true
    }
}
fun ast_declaration_statement_ptr(): *ast_node {
    var to_ret.construct(): declaration_statement 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::declaration_statement(to_ret))
    return ptr
}
obj declaration_statement (Object) {
    fun construct(): *declaration_statement  {
        return this
    }
    fun copy_construct(old: *declaration_statement) {
    }
    fun destruct() {
    }
    fun operator=(other: ref declaration_statement) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref declaration_statement): bool {
        return true
    }
}
fun ast_if_comp_ptr(): *ast_node {
    var to_ret.construct(): if_comp 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::if_comp(to_ret))
    return ptr
}
obj if_comp (Object) {
    fun construct(): *if_comp  {
        return this
    }
    fun copy_construct(old: *if_comp) {
    }
    fun destruct() {
    }
    fun operator=(other: ref if_comp) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref if_comp): bool {
        return true
    }
}
fun ast_simple_passthrough_ptr(): *ast_node {
    var to_ret.construct(): simple_passthrough 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::simple_passthrough(to_ret))
    return ptr
}
obj simple_passthrough (Object) {
    fun construct(): *simple_passthrough  {
        return this
    }
    fun copy_construct(old: *simple_passthrough) {
    }
    fun destruct() {
    }
    fun operator=(other: ref simple_passthrough) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref simple_passthrough): bool {
        return true
    }
}
fun ast_passthrough_params_ptr(): *ast_node {
    var to_ret.construct(): passthrough_params 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::passthrough_params(to_ret))
    return ptr
}
obj passthrough_params (Object) {
    fun construct(): *passthrough_params  {
        return this
    }
    fun copy_construct(old: *passthrough_params) {
    }
    fun destruct() {
    }
    fun operator=(other: ref passthrough_params) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref passthrough_params): bool {
        return true
    }
}
fun ast_in_passthrough_params_ptr(): *ast_node {
    var to_ret.construct(): in_passthrough_params 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::in_passthrough_params(to_ret))
    return ptr
}
obj in_passthrough_params (Object) {
    fun construct(): *in_passthrough_params  {
        return this
    }
    fun copy_construct(old: *in_passthrough_params) {
    }
    fun destruct() {
    }
    fun operator=(other: ref in_passthrough_params) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref in_passthrough_params): bool {
        return true
    }
}
fun ast_out_passthrough_params_ptr(): *ast_node {
    var to_ret.construct(): out_passthrough_params 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::out_passthrough_params(to_ret))
    return ptr
}
obj out_passthrough_params (Object) {
    fun construct(): *out_passthrough_params  {
        return this
    }
    fun copy_construct(old: *out_passthrough_params) {
    }
    fun destruct() {
    }
    fun operator=(other: ref out_passthrough_params) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref out_passthrough_params): bool {
        return true
    }
}
fun ast_opt_string_ptr(): *ast_node {
    var to_ret.construct(): opt_string 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::opt_string(to_ret))
    return ptr
}
obj opt_string (Object) {
    fun construct(): *opt_string  {
        return this
    }
    fun copy_construct(old: *opt_string) {
    }
    fun destruct() {
    }
    fun operator=(other: ref opt_string) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref opt_string): bool {
        return true
    }
}
fun ast_param_assign_ptr(): *ast_node {
    var to_ret.construct(): param_assign 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::param_assign(to_ret))
    return ptr
}
obj param_assign (Object) {
    fun construct(): *param_assign  {
        return this
    }
    fun copy_construct(old: *param_assign) {
    }
    fun destruct() {
    }
    fun operator=(other: ref param_assign) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref param_assign): bool {
        return true
    }
}
fun ast_function_call_ptr(): *ast_node {
    var to_ret.construct(): function_call 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::function_call(to_ret))
    return ptr
}
obj function_call (Object) {
    fun construct(): *function_call  {
        return this
    }
    fun copy_construct(old: *function_call) {
    }
    fun destruct() {
    }
    fun operator=(other: ref function_call) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref function_call): bool {
        return true
    }
}
fun ast_value_ptr(): *ast_node {
    var to_ret.construct(): value 
    var ptr = new<ast_node>()
    ptr->copy_construct(&ast_node::value(to_ret))
    return ptr
}
obj value (Object) {
    fun construct(): *value  {
        return this
    }
    fun copy_construct(old: *value) {
    }
    fun destruct() {
    }
    fun operator=(other: ref value) {
        destruct()
        copy_construct(&other)
    }
    fun operator==(other: ref value): bool {
        return true
    }
}

fun get_ast_children(node: *ast_node): vector<*ast_node> {
    match (*node) {
        ast_node::translation_unit(backing) return backing.children
        ast_node::import(backing) return vector<*ast_node>()
        ast_node::identifier(backing) return vector<*ast_node>()
        ast_node::type_def(backing) return vector<*ast_node>()
        ast_node::adt_def(backing) return vector<*ast_node>()
        ast_node::function(backing) return vector<*ast_node>()
        ast_node::code_block(backing) return vector<*ast_node>()
        ast_node::typed_parameter(backing) return vector<*ast_node>()
        ast_node::expression(backing) return vector<*ast_node>()
        ast_node::boolean_expression(backing) return vector<*ast_node>()
        ast_node::statement(backing) return vector<*ast_node>()
        ast_node::if_statement(backing) return vector<*ast_node>()
        ast_node::match_statement(backing) return vector<*ast_node>()
        ast_node::case_statement(backing) return vector<*ast_node>()
        ast_node::while_loop(backing) return vector<*ast_node>()
        ast_node::for_loop(backing) return vector<*ast_node>()
        ast_node::return_statement(backing) return vector<*ast_node>()
        ast_node::break_statement(backing) return vector<*ast_node>()
        ast_node::continue_statement(backing) return vector<*ast_node>()
        ast_node::defer_statement(backing) return vector<*ast_node>()
        ast_node::assignment_statement(backing) return vector<*ast_node>()
        ast_node::declaration_statement(backing) return vector<*ast_node>()
        ast_node::if_comp(backing) return vector<*ast_node>()
        ast_node::simple_passthrough(backing) return vector<*ast_node>()
        ast_node::passthrough_params(backing) return vector<*ast_node>()
        ast_node::in_passthrough_params(backing) return vector<*ast_node>()
        ast_node::out_passthrough_params(backing) return vector<*ast_node>()
        ast_node::opt_string(backing) return vector<*ast_node>()
        ast_node::param_assign(backing) return vector<*ast_node>()
        ast_node::function_call(backing) return vector<*ast_node>()
        ast_node::value(backing) return vector<*ast_node>()
    }
}
fun get_ast_name(node: *ast_node): string {
    match (*node) {
        ast_node::translation_unit(backing) return string("translation_unit: ") + backing.name
        ast_node::import(backing) return string("import: ") + backing.name
        ast_node::identifier(backing) return string("identifier")
        ast_node::type_def(backing) return string("type_def: ") + backing.name
        ast_node::adt_def(backing) return string("adt_def: ") + backing.name
        ast_node::function(backing) return string("function")
        ast_node::code_block(backing) return string("code_block")
        ast_node::typed_parameter(backing) return string("typed_parameter")
        ast_node::expression(backing) return string("expression")
        ast_node::boolean_expression(backing) return string("boolean_expression")
        ast_node::statement(backing) return string("statement")
        ast_node::if_statement(backing) return string("if_statement")
        ast_node::match_statement(backing) return string("match_statement")
        ast_node::case_statement(backing) return string("case_statement")
        ast_node::while_loop(backing) return string("while_loop")
        ast_node::for_loop(backing) return string("for_loop")
        ast_node::return_statement(backing) return string("return_statement")
        ast_node::break_statement(backing) return string("break_statement")
        ast_node::continue_statement(backing) return string("continue_statement")
        ast_node::defer_statement(backing) return string("defer_statement")
        ast_node::assignment_statement(backing) return string("assignment_statement")
        ast_node::declaration_statement(backing) return string("declaration_statement")
        ast_node::if_comp(backing) return string("if_comp")
        ast_node::simple_passthrough(backing) return string("simple_passthrough")
        ast_node::passthrough_params(backing) return string("passthrough_params")
        ast_node::in_passthrough_params(backing) return string("in_passthrough_params")
        ast_node::out_passthrough_params(backing) return string("out_passthrough_params")
        ast_node::opt_string(backing) return string("opt_string")
        ast_node::param_assign(backing) return string("param_assign")
        ast_node::function_call(backing) return string("function_call")
        ast_node::value(backing) return string("value")
    }
}

fun ast_to_dot(root: *ast_node): string {
    var ret = string("digraph Kaken {\n")
    var counter = 0
    var node_name_map = map<*ast_node, string>()
    var get_name = fun(node: *ast_node): string {
        if (node_name_map.contains_key(node))
            return node_name_map[node]
        var escaped = string("")
        get_ast_name(node).data.for_each(fun(c: char) {
            if (c != '"')
                escaped += c
            else
                escaped += "\\\""
        })
        escaped += to_string(counter++)
        node_name_map.set(node, escaped)
        return escaped
    }
    var helper: fun(*ast_node):void = fun(node: *ast_node) {
        get_ast_children(node).for_each(fun(child: *ast_node) {
            if (!child)
                return; // where on earth does the null come from
            ret += string("\"") + get_name(node) + "\" -> \"" + get_name(child) + "\"\n";
            helper(child)
        })
    }
    if (root)
        helper(root)
    return ret + "}"
}

