(with_import "./collections.kp"
(let (
    ; For right now we only support calling partial_eval in such a way that it partial evals against
    ; the root env, but this is could and really should be extended. We could at least check if the env we're called with
    ; is the root_env, or if what we look up in whatever env is passed in matches something in the root env
    ; Care should also be taken when evaluating outside combinators to have them be in the right env, etc

    ; Here is every form in k'
    ; True
    ; False
    ; Env: *KPEnv
    ; Combiner: KPCombiner / BuiltinCombiner: KPBuiltinCombiner
    ; String: str
    ; Symbol: str
    ; Int: int
    ; Array: rc<vec<KPValue>>
    ; Nil


    ; Ok, some more things we need / need to change
    ;   1) meta...
    ;        Honestly, I'm tempted to get rid of it

    ; Possible marked values
    ; ['val v]                  - v is a value that evaluates to itself, and not a combiner or env, as those have their own metadata. Not an array or symbol
    ;                               That means it's true/false/a string/ an int/nil
    ; ['marked_array is_val a]  - a contains marked values. if is_val, then it's the value version, and must be stripped back into (array ...),
    ;                               otherwise it's a calling form, and should be lowered back to (...). Also, if it's is_val, partial_eval won't perform a call, etc
    ; ['marked_symbol is_val s] - a symbol. is_val has the same meaning as in marked_array
    ; ['comb wrap_level de? se variadic params body] - A combiner. Contains the static env and the actual function, if possible.
    ;                                                                    It is possible to have a combiner without an actual function, but that's only generated when
    ;                                                                    we know it's about to be called and we won't have to strip-lower it
    ; ['prim_comb <handler_function>]                     - A primitive combiner! It has it's own special handler function to partial eval
    ; ['env is_real de_bruijn_idx_or_nil [ ['symbol marked_value ]... <upper_marked_env> ]] - A marked env


    val? (lambda (x) (= 'val (idx x 0)))
    .val (lambda (x) (idx x 1))
    marked_array? (lambda (x) (= 'marked_array (idx x 0)))
    .marked_array_is_val (lambda (x) (idx x 1))
    .marked_array_values (lambda (x) (idx x 2))
    marked_symbol? (lambda (x) (= 'marked_symbol (idx x 0)))
    .marked_symbol_is_val (lambda (x) (idx x 1))
    .marked_symbol_value  (lambda (x) (idx x 2))
    comb? (lambda (x) (= 'comb (idx x 0)))
    .comb (lambda (x) (slice x 1 -1))
    prim_comb? (lambda (x) (= 'prim_comb (idx x 0)))
    .prim_comb (lambda (x) (idx x 1))
    marked_env? (lambda (x) (= 'env (idx x 0)))
    marked_env_real? (lambda (x) (idx x 1))
    .marked_env_idx (lambda (x) (idx x 2))
    .env_marked (lambda (x) (idx x 3))

    later? (rec-lambda recurse (x) (or (and (marked_array? x)  (or (= false (.marked_array_is_val x)) (foldl (lambda (a x) (or a (recurse x))) false (.marked_array_values x))))
                                       (and (marked_symbol? x) (= false (.marked_symbol_is_val x)))
                                      ; This is now taken care of via the de Bruijn >= 0 check in call, otherwise these are values, kinda, as long as they don't go negative (or are real)
                                      ;(and (marked_env? x)    (not (marked_env_real? x)))
                                      ;(and (comb? x)          (let ([wrap_level de? se variadic params body] (.comb x)
                                      ;                              ; this is the complex bit - we should do something like check if
                                      ;                              ; se is fake check to see if there are symbols or eval that could use it
                                      ;                              ; or a sub-comb's se, or if de is non-nil and used in some sub-call.
                                      ;                              comb_is_later (recurse se)
                                      ;                             ) comb_is_later))
                                   ))
    false? (lambda (x) (cond (and (marked_array? x)  (= false (.marked_array_is_val x)))    (error (str "got a later marked_array passed to false? " x))
                             (and (marked_symbol? x) (= false (.marked_symbol_is_val x)))   (error (str "got a later marked_symbol passed to false? " x))
                             (val? x)                                                       (not (.val x))
                             true                                                           false))

    env-lookup-helper (rec-lambda recurse (dict key i fail success) (cond (and (= i (- (len dict) 1)) (= nil (idx dict i)))  (fail)
                                                                          (= i (- (len dict) 1))                             (recurse (.env_marked (idx dict i)) key 0 fail success)
                                                                          (= key (idx (idx dict i) 0))                       (success (idx (idx dict i) 1))
                                                                          true                                               (recurse dict key (+ i 1) fail success)))
    env-lookup (lambda (env key) (env-lookup-helper (.env_marked env) key 0 (lambda () (error (str key " not found in env " (.env_marked env)))) (lambda (x) x)))

    mark (rec-lambda recurse (x) (cond   (env? x)        (error (str "called mark with an env " x))
                                         (combiner? x)   (error (str "called mark with a combiner " x))
                                         (symbol? x)     ['marked_symbol false x]
                                         (array? x)      ['marked_array false (map recurse x)]
                                         true            ['val x]))

    indent_str (rec-lambda recurse (i) (if (= i 0) ""
                                                   (str "   " (recurse (- i 1)))))

    str_strip (lambda (& args) (lapply str (concat (slice args 0 -2) [((rec-lambda recurse (x)
        (cond (val? x)           (.val x)
              (marked_array? x)  (let (stripped_values (map recurse (.marked_array_values x)))
                                      (if (.marked_array_is_val x) (cons array stripped_values)
                                                                   stripped_values))
              (marked_symbol? x) (if (.marked_symbol_is_val x) ['quote (.marked_symbol_value x)]
                                                               (.marked_symbol_value x))
              (comb? x)          (let ([wrap_level de? se variadic params body] (.comb x))
                                      (str "<comb " wrap_level " " de? " <se " (recurse se) "> " params " " (recurse body) ">"))
              (prim_comb? x)     (idx x 2)
              (marked_env? x)    (let (e (.env_marked x)
                                       index (.marked_env_idx x)
                                       u (idx e -1)
                                       ) (if u (str "<" (if (marked_env_real? x) "real" "fake") " ENV idx: " (str index) ", " (map (lambda ([k v]) [k (recurse v)]) (slice e 0 -2)) " upper: " (recurse u)  ">")
                                               "<no_upper_likely_root_env>"))
              true               (error (str "some other str_strip? |" x "|"))
        )
    ) (idx args -1))])))
    print_strip (lambda (& args) (println (lapply str_strip args)))

    strip (let (helper (rec-lambda recurse (x need_value)
        (cond (val? x)           (.val x)
              (marked_array? x)  (let (stripped_values (map (lambda (x) (recurse x need_value)) (.marked_array_values x)))
                                      (if (.marked_array_is_val x) (if need_value (error (str "needed value for this strip but got" x)) (cons array stripped_values))
                                                                   stripped_values))
              (marked_symbol? x) (if (.marked_symbol_is_val x) (if need_value (error (str "needed value for this strip but got" x)) [quote (.marked_symbol_value x)])
                                                               (.marked_symbol_value x))
              (comb? x)          (let ([wrap_level de? se variadic params body] (.comb x)
                                       de_entry (if de? [de?] [])
                                       final_params (if variadic (concat (slice params 0 -2) '& [(idx params -1)]) params)
                                       ; Honestly, could trim down the env to match what could be evaluated in the comb
                                       ; Also if this isn't real, lower to a call to vau
                                       se_env (if (marked_env_real? se) (recurse se true) nil)
                                       body_v (recurse body false)
                                       ve (concat [vau] de_entry [final_params] [body_v])
                                       fe ((rec-lambda recurse (x i) (if (= i 0) x (recurse [wrap x] (- i 1)))) ve wrap_level)
                                 ) (if se_env (eval fe se_env) fe))
              (prim_comb? x)     (idx x 2)
                                          ; env emitting doesn't pay attention to real value right now, not sure if that makes sense
                                          ; TODO: properly handle de Bruijn indexed envs
              (marked_env? x)    (cond (and (not need_value) (= 0 (.marked_env_idx x))) [current-env]
                                       true                                             (let (_ (if (not (marked_env_real? x)) (error (str_strip "trying to emit fake env!" x)))
                                                                                            upper (idx (.env_marked x) -1)
                                                                                            upper_env (if upper (recurse upper true) empty_env)
                                                                                            just_entries (slice (.env_marked x) 0 -2)
                                                                                            vdict (map (lambda ([k v]) [k (recurse v true)]) just_entries)
                                                                                        ) (add-dict-to-env upper_env vdict)))
              true               (error (str "some other strip? " x))
        )
    ))  (lambda (x) (let (_ (print_strip "stripping: " x) r (helper x false) _ (println "result of strip " r)) r)))

    ; A bit wild, but what if instead of is_value we had an evaluation level integer, kinda like wrap?
    ; when lowering, it could just turn into multiple evals or somesuch, though we'd have to be careful of envs...
    try_unval (rec-lambda recurse (x fail_f)
        (cond (marked_array? x) (if (not (.marked_array_is_val x)) [false (fail_f x)]
                                                                   (let ([sub_ok subs] (foldl (lambda ([ok a] x) (let ([nok p] (recurse x fail_f))
                                                                                                                      [(and ok nok) (concat a [p])]))
                                                                                              [true []]
                                                                                              (.marked_array_values x)))
                                                                        [sub_ok ['marked_array false subs]]))
              (marked_symbol? x) (if (.marked_symbol_is_val x) [true ['marked_symbol false (.marked_symbol_value x)]]
                                                               [false (fail_f x)])
              true               [true x]
        )
    )
    try_unval_array (lambda (x) (foldl (lambda ([ok a] x) (let ([nok p] (try_unval x (lambda (_) nil)))
                                                               [(and ok nok) (concat a [p])]))
                                       [true []]
                                       x))

    ensure_val (rec-lambda recurse (x)
        (cond (marked_array? x)  ['marked_array true (map recurse (.marked_array_values x))]
              (marked_symbol? x) ['marked_symbol true (.marked_symbol_value x)]
              true               x
        )
    )

    ; This is a conservative analysis, since we can't always tell what constructs introduce
    ; a new binding scope & would be shadowing... we should at least be able to implement it for
    ; vau/lambda, but we won't at first
    in_array (let (helper (rec-lambda recurse (x a i) (cond (= i (len a))   false
                                                            (= x (idx a i)) true
                                                            true            (recurse x a (+ i 1)))))
                  (lambda (x a) (helper x a 0)))
    ; TODO: make this check for stop envs using de Bruijn indicies
    contains_symbols (rec-lambda recurse (stop_envs symbols x) (cond
              (val? x)           false
              (marked_symbol? x) (let (r (in_array (.marked_symbol_value x) symbols)
                                       _ (if r (println "!!! contains symbols found " x " in symbols " symbols)))
                                       r)
              (marked_array? x)  (foldl (lambda (a x) (or a (recurse stop_envs symbols x))) false (.marked_array_values x))
              (comb? x)          (let ([wrap_level de? se variadic params body] (.comb x))
                                      (or (recurse stop_envs symbols se) (recurse stop_envs (filter (lambda (y) (not (or (= de? y) (in_array y params)))) symbols) body)))

              (prim_comb? x)    false
              (marked_env? x)   (let (inner (.env_marked x))
                                     (cond (in_array x stop_envs)                                                                       false
                                           (foldl (lambda (a x) (or a (recurse stop_envs symbols (idx x 1)))) false (slice inner 0 -2)) true
                                           (idx inner -1)                                                                               (recurse stop_envs symbols (idx inner -1))
                                           true                                                                                         false))
              true              (error (str "Something odd passed to contains_symbols " x))
    ))

    is_all_values (lambda (evaled_params) (foldl (lambda (a x) (and a (not (later? x)))) true evaled_params))

    ; * TODO: allowing envs to be shead if they're not used.
    shift_envs (rec-lambda recurse (cutoff d x) (cond
        (val? x)            [true x]
        (marked_env? x)     (let ([_env is_real dbi meat] x
                                  [nmeat_ok nmeat] (foldl (lambda ([ok r] [k v]) (let ([tok tv] (recurse cutoff d v)) [(and ok tok) (concat r [[k tv]])])) [true []] (slice meat 0 -2))
                                  [nupper_ok nupper] (if (idx meat -1) (recurse cutoff d (idx meat -1)) [true nil])
                                  ndbi (cond (nil? dbi)      nil
                                             (>= dbi cutoff) (+ dbi d)
                                             true            dbi)
                              ) [(and nmeat_ok nupper_ok (or is_real (and ndbi (>= ndbi 0)))) ['env is_real ndbi (concat nmeat [nupper])]])
        (comb? x)           (let ([wrap_level de? se variadic params body] (.comb x)
                                    [se_ok nse] (recurse cutoff d se)
                                    [body_ok nbody] (recurse (+ cutoff 1) d body)
                                ) [(and se_ok body_ok) ['comb wrap_level de? nse variadic params nbody]])
        (prim_comb? x)      [true x]
        (marked_symbol? x)  [true x]
        (marked_array? x)   (let ([insides_ok insides] (foldl (lambda ([ok r] tx) (let ([tok tr] (recurse cutoff d tx)) [(and ok tok) (concat r [tr])])) [true []] (.marked_array_values x)))
                                  [insides_ok ['marked_array (.marked_array_is_val x) insides]])
        true                (error (str "impossible shift_envs value " x))
    ))
    increment_envs (lambda (x) (idx (shift_envs 0  1 x) 1))
    decrement_envs (lambda (x)      (shift_envs 0 -1 x))

    ; TODO: instead of returning the later symbols, we could create a new value of a new type
    ; ['ref de_bruijn_index_of_env index_into_env] or somesuch. Could really simplify
    ; compiling, and I think make partial-eval more efficient. More accurate closes_over analysis too, I think
    make_tmp_inner_env (lambda (params de? de)
            ['env false 0 (concat (map (lambda (p) [p ['marked_symbol false p]]) params) (if (= nil de?) [] [ [de? ['marked_symbol false de?]] ]) [(increment_envs de)])])


    partial_eval_helper (rec-lambda recurse (x env env_stack indent)
        (cond   (val? x)            x
                (marked_env? x)     (let (dbi (.marked_env_idx x))
                                          (if dbi (let (new_env (idx env_stack dbi)
                                                        ndbi (.marked_env_idx new_env)
                                                        ;_ (if (!= dbi ndbi) (error (str (str_strip "same env with different dbis " x) (str_strip " and " new_env))))
                                                        _ (if (!= 0 ndbi) (error (str_strip "new env with non-zero dbis " x)))
                                                        _ (println (str_strip "replacing " x) (str_strip " with " new_env))
                                                        )
                                                        (if (= 0 dbi) new_env (idx (shift_envs 0 dbi new_env) 1)))
                                                  x))

                (comb? x)           (let ([wrap_level de? se variadic params body] (.comb x))
                                        (if (or (and (not (marked_env_real? env)) (not (marked_env_real? se)))   ; both aren't real, re-evaluation of creation site
                                                (and      (marked_env_real? env)  (not (marked_env_real? se))))  ; new env real, but se isn't - creation!
                                             (let (inner_env (make_tmp_inner_env params de? env))
                                                  ['comb wrap_level de? env variadic params (recurse body inner_env (cons inner_env env_stack) (+ indent 1))])
                                             x))
                (prim_comb? x)      x
                (marked_symbol? x)  (if (.marked_symbol_is_val x) x
                                                                  (env-lookup env (.marked_symbol_value x)))
                (marked_array? x)   (cond (.marked_array_is_val x) x
                                          (= 0 (len (.marked_array_values x))) (error "Partial eval on empty array")
                                          true (let (values (.marked_array_values x)
                                                      ;_ (println (indent_str indent) "partial_evaling comb " (idx values 0))
                                                      _ (print_strip (indent_str indent) "partial_evaling comb " (idx values 0))
                                                     comb (recurse (idx values 0) env env_stack (+ 1 indent))
                                                     literal_params (slice values 1 -1)
                                                      _ (println (indent_str indent) "Going to do an array call!")
                                                      _ (print_strip (indent_str indent) "     total is " x)
                                                      _ (print_strip (indent_str indent) "     evaled comb is  " comb)
                                                      ident (+ 1 indent)
                                                     )
                                                     (cond (prim_comb? comb) ((.prim_comb comb) env env_stack literal_params (+ 1 indent))
                                                           (comb? comb)      (let (
                                                                                 rp_eval (lambda (p) (recurse p env env_stack (+ 1 indent)))
                                                                                 [wrap_level de? se variadic params body] (.comb comb)
                                                                                 ensure_val_params (map ensure_val literal_params)
                                                                                 [ok appropriatly_evaled_params] ((rec-lambda param-recurse (wrap cparams)
                                                                                        (if (!= 0 wrap)
                                                                                            (let (pre_evaled (map rp_eval cparams)
                                                                                                  [ok unval_params] (try_unval_array pre_evaled))
                                                                                                 (if (not ok) [ok nil]
                                                                                                    (let (evaled_params (map rp_eval unval_params))
                                                                                                         (param-recurse (- wrap 1) evaled_params))))
                                                                                            [true cparams])
                                                                                    ) wrap_level ensure_val_params)
                                                                                 ok_and_non_later (and ok (is_all_values appropriatly_evaled_params))
                                                                                 ) (if (not ok_and_non_later) ['marked_array false (cons comb (if (> wrap_level 0) (map rp_eval literal_params)
                                                                                                                                                     literal_params))]
                                                                                 (let (
                                                                                 final_params (if variadic (concat (slice appropriatly_evaled_params 0 (- (len params) 1))
                                                                                                                   [['marked_array true (slice appropriatly_evaled_params (- (len params) 1) -1)]])
                                                                                                           appropriatly_evaled_params)
                                                                                 [de_real de_entry] (if (!= nil de?) [ (marked_env_real? env) [ [de? (increment_envs env) ] ] ]
                                                                                                                     [ true []])
                                                                                 ;_ (println (indent_str indent) "final_params params " final_params)
                                                                                 inner_env ['env (and de_real (marked_env_real? se)) 0 (concat (zip params (map (lambda (x) (increment_envs x)) final_params)) de_entry [(increment_envs se)])]
                                                                                 _ (print_strip (indent_str indent) " with inner_env is " inner_env)
                                                                                 _ (print_strip (indent_str indent) "going to eval " body)

                                                                                 tmp_func_result (recurse body inner_env (cons inner_env env_stack) (+ 1 indent))
                                                                                 _ (print_strip (indent_str indent) "evaled result of function call  is " tmp_func_result)
                                                                                 [able_to_sub_env func_result] (decrement_envs tmp_func_result)
                                                                                 result_is_later (later? func_result)
                                                                                 _ (print_strip (indent_str indent) "success? " able_to_sub_env " decremented result of function call  is " tmp_func_result)
                                                                                 stop_envs ((rec-lambda ser (a e) (if e (ser (cons e a) (idx (.env_marked e) -1)) a)) [] se)
                                                                                 result_closes_over (contains_symbols stop_envs (concat params (if de? [de?] [])) func_result)
                                                                                 _ (println (indent_str indent) "func call able_to_sub: " able_to_sub_env " result is later? " result_is_later " and result_closes_over " result_closes_over)
                                                                                 ; This could be improved to a specialized version of the function
                                                                                 ; just by re-wrapping it in a comb instead if we wanted.
                                                                                 ; Something to think about!
                                                                                 result (if (or (not able_to_sub_env) (and result_is_later result_closes_over))
                                                                                                ['marked_array false (cons comb (if (> wrap_level 0) (map rp_eval literal_params)
                                                                                                                                                     literal_params))]
                                                                                                func_result)
                                                                             ) result)))
                                                           (later? comb)     ['marked_array false (cons comb literal_params)]
                                                            true             (error (str "impossible comb value " x)))))
                true                (error (str "impossible partial_eval value " x))
        )
    )
    needs_params_val_lambda (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (rec-lambda recurse (de env_stack params indent) (let (
                ;_ (println "partial_evaling params in need_params_val_lambda for " f_sym " is " params)
                evaled_params (map (lambda (p) (partial_eval_helper p de env_stack (+ 1 indent))) params)
            )
            (if (is_all_values evaled_params) (mark (lapply actual_function (map strip evaled_params)))
                                              ['marked_array false (cons ['prim_comb recurse actual_function] evaled_params)])))
        ) [f_sym ['prim_comb handler actual_function]]))
    give_up_eval_params (vau de (f_sym) (let (
        actual_function (eval f_sym de)
        handler (rec-lambda recurse (de env_stack params indent) (let (
                _ (println "partial_evaling params in give_up_eval_params for " f_sym " is " params)
                evaled_params (map (lambda (p) (partial_eval_helper p de env_stack (+ 1 indent))) params)
            )
            ['marked_array false (cons ['prim_comb recurse actual_function] evaled_params)]))
        ) [f_sym ['prim_comb handler actual_function]]))

    ; !!!!!!
    ; ! I think needs_params_val_lambda should be combined with parameters_evaled_proxy
    ; !!!!!!
    parameters_evaled_proxy (rec-lambda recurse (pasthr_ie inner_f) (lambda (de env_stack params indent) (let (
        _ (println "partial_evaling params in parameters_evaled_proxy is " params)
        [evaled_params l] (foldl (lambda ([ac i] p) (let (p (partial_eval_helper p de env_stack (+ 1 indent)))
                                                         [(concat ac [p]) (+ i 1)]))
                                 [[] 0]
                                 params)
    ) (inner_f (lambda (& args) (lapply (recurse pasthr_ie inner_f) args)) de env_stack evaled_params indent))))

    root_marked_env ['env true nil [
        ; Ok, so for combinators, it should partial eval the body.
        ; It should then check to see if the partial-evaled body has closed over
        ; any 'later values from above the combinator. If so, the combinator should
        ; evaluate to a ['later [vau de? params (strip partially_evaled_body)]], otherwise it can evaluate to a 'comb.
        ; Note that this 'later may be re-evaluated later if the parent function is called.
        ['vau ['prim_comb (rec-lambda recurse (de env_stack params indent) (let (
            mde?         (if (= 3 (len params)) (idx params 0))
            vau_mde?     (if (= nil mde?) [] [mde?])
            de?          (if mde? (.marked_symbol_value mde?))
            vau_de?      (if (= nil de?) [] [de?])
            raw_marked_params (if (= nil de?) (idx params 0) (idx params 1))
            raw_params (map (lambda (x) (if (not (marked_symbol? x)) (error (str "not a marked symbol " x))
                                            (.marked_symbol_value x))) (.marked_array_values raw_marked_params))
            [variadic vau_params]  (foldl (lambda ([v a] x) (if (= x '&) [true a] [v (concat a [x])])) [false []] raw_params)
            body        (if (= nil de?) (idx params 1) (idx params 2))
            inner_env (make_tmp_inner_env vau_params de? de)
            _ (print_strip (indent_str indent) "in vau, evaluating body with 'later params - " body)
            pe_body (partial_eval_helper body inner_env (cons inner_env env_stack) (+ 1 indent))
            _ (print_strip (indent_str indent) "in vau, result of evaluating body was " pe_body)
        ) ['comb 0 de? de variadic vau_params pe_body]
        )) vau]]

        ['wrap ['prim_comb (parameters_evaled_proxy 0 (lambda (recurse de env_stack [evaled] indent)
              (if (comb? evaled) (let ([wrap_level de? se variadic params body] (.comb evaled)
                                        wrapped_marked_fun ['comb (+ 1 wrap_level) de? se variadic params body]
                                      ) wrapped_marked_fun)
                                 ['marked_array false [['prim_comb recurse wrap] evaled]]))
        ) wrap]]
        ['unwrap ['prim_comb (parameters_evaled_proxy 0 (lambda (recurse de env_stack [evaled] indent)
             (if (comb? evaled) (let ([wrap_level de? se variadic params body] (.comb evaled)
                                        unwrapped_marked_fun ['comb (- wrap_level 1) de? se variadic params body]
                                      ) unwrapped_marked_fun)
                                 ['marked_array false [['prim_comb recurse unwrap] evaled]]))
        ) unwrap]]

        ['eval ['prim_comb (rec-lambda recurse (de env_stack params indent) (let (
            self ['prim_comb recurse eval]
            eval_env (if (= 2 (len params)) (partial_eval_helper (idx params 1) de env_stack (+ 1 indent))
                                            de)
            eval_env_v (if (= 2 (len params)) [eval_env] [])
         ) (if (not (marked_env? eval_env)) (do (print_strip (indent_str indent) "eval got not a marked env " eval_env) ['marked_array false (cons self params)])
                                            (let (
            _ (print_strip (indent_str indent) " partial_evaling_body the first time " (idx params 0))
            body1 (partial_eval_helper (idx params 0) de env_stack (+ 1 indent))
            _ (print_strip (indent_str indent) "after first eval of param " body1)

            ; With this, we don't actually fail as this is always a legitimate uneval
            fail_handler (lambda (failed) ['marked_array false (concat [self failed] eval_env_v)])
            [ok unval_body] (try_unval body1 fail_handler)
            self_fallback (fail_handler body1)
            _ (print_strip (indent_str indent) "partial_evaling body for the second time in eval " unval_body)
            body2 (if (= self_fallback unval_body) self_fallback (partial_eval_helper unval_body eval_env env_stack (+ 1 indent)))
            _ (print_strip (indent_str indent) "and body2 is " body2)
            ) body2))
        )) eval]]

        ;TODO: This could go a lot farther, not stopping after the first 'later, etc
        ; Also, GAH on odd params - but only one by one - a later odd param can't be imm_eval cuz it will
        ; be frozen if an earlier cond is 'later....
        ['cond ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack evaled_params indent)
            (if (!= 0 (% (len evaled_params) 2)) (error (str "partial eval cond with odd evaled_params " evaled_params))
                ((rec-lambda recurse_inner (i)
                                          (cond (later? (idx evaled_params i))  ['marked_array false (cons ['prim_comb recurse cond] (slice evaled_params i -1))]
                                                (false? (idx evaled_params i))  (recurse_inner (+ 2 i))
                                                true                            (idx evaled_params (+ 1 i))) ; we could partially_eval again passing in immediate
                                                                                                             ; eval if it was true, to partially counteract the above GAH
                 ) 0)
            )
        )) cond]]
        (needs_params_val_lambda symbol?)
        (needs_params_val_lambda int?)
        (needs_params_val_lambda string?)
        ; not even a gah, but kinda!
        ['combiner? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_param] indent)
            (cond (comb? evaled_param)          ['val true]
                  (prim_comb? evaled_param)     ['val true]
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse combiner?] evaled_param]]
                  true                          ['val false]
            )
        )) combiner?]]
        ; not even a gah, but kinda!
        ['env? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_param] indent)
            (cond (marked_env? evaled_param)    ['val true]
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse env?] evaled_param]]
                  true                          ['val false]
            )
        )) env?]]
        (needs_params_val_lambda nil?)
        (needs_params_val_lambda bool?)
        (needs_params_val_lambda str-to-symbol)
        (needs_params_val_lambda get-text)

        ['array? ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_param] indent)
            (cond 
                  (later? evaled_param)         ['marked_array false [['prim_comb recurse array?] evaled_param]]
                  (marked_array? evaled_param)  ['val true]
                  true                          ['val false]
            )
        )) array?]]
        ; This one's sad, might need to come back to it.
        ; We need to be able to differentiate between half-and-half arrays
        ; for when we ensure_params_values or whatever, because that's super wrong
        ['array ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack evaled_params indent)
                                                (if (is_all_values evaled_params) ['marked_array true evaled_params]
                                                                                  ['marked_array false (cons ['prim_comb recurse array] evaled_params)])
        )) array]]
        ['len ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_param] indent)
            (cond (later? evaled_param)         ['marked_array false [['prim_comb recurse len] evaled_param]]
                  (marked_array? evaled_param)  ['val (len (.marked_array_values evaled_param))]
                  true                          (error (str "bad type to len " evaled_param))
            )
        )) len]]
        ['idx ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_array evaled_idx] indent)
            (cond (and (val? evaled_idx) (marked_array? evaled_array) (.marked_array_is_val evaled_array)) (idx (.marked_array_values evaled_array) (.val evaled_idx))
                  true                                                                                     ['marked_array false [['prim_comb recurse idx] evaled_array evaled_idx]]
            )
        )) idx]]
        ['slice ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack [evaled_array evaled_begin evaled_end] indent)
            (cond (and (val? evaled_begin) (val? evaled_end) (marked_array? evaled_array) (.marked_array_is_val evaled_array))
                            ['marked_array true (slice (.marked_array_values evaled_array) (.val evaled_begin) (.val evaled_end))]
                  true      ['marked_array false [['prim_comb recurse slice] evaled_array evaled_idx evaled_begin evaled_end]]
            )
        )) slice]]
        ['concat ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack evaled_params indent)
            (cond (foldl (lambda (a x) (and a (and (marked_array? x) (.marked_array_is_val x)))) true evaled_params) ['marked_array true (lapply concat (map (lambda (x)
                                                                                                                                                             (.marked_array_values x))
                                                                                                                                                            evaled_params))]
                  true                                                                                              ['marked_array false (cons ['prim_comb recurse concat] evaled_params)]
            )
        )) concat]]

        (needs_params_val_lambda +)
        (needs_params_val_lambda -)
        (needs_params_val_lambda *)
        (needs_params_val_lambda /)
        (needs_params_val_lambda %)
        (needs_params_val_lambda &)
        (needs_params_val_lambda |)
        (needs_params_val_lambda <<)
        (needs_params_val_lambda >>)
        (needs_params_val_lambda =)
        (needs_params_val_lambda !=)
        (needs_params_val_lambda <)
        (needs_params_val_lambda <=)
        (needs_params_val_lambda >)
        (needs_params_val_lambda >=)

        ; these could both be extended to eliminate other known true values except for the end and vice-versa
        ['and ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack evaled_params indent)
            ((rec-lambda inner_recurse (i)
                                      (cond (= i (- (len evaled_params) 1))          (idx evaled_params i)
                                            (later? (idx evaled_params i))           ['marked_array false (cons ['prim_comb recurse and] (slice evaled_params i -1))]
                                            (false? (idx evaled_params i))           (idx evaled_params i)
                                            true                                     (inner_recurse (+ 1 i)))
             ) 0)
        )) and]]
        ; see above for improvement
        ['or ['prim_comb (parameters_evaled_proxy nil (lambda (recurse de env_stack evaled_params indent)
            ((rec-lambda inner_recurse (i)
                                      (cond (= i (- (len evaled_params) 1))          (idx evaled_params i)
                                            (later? (idx evaled_params i))           ['marked_array false (cons ['prim_comb recurse or] (slice evaled_params i -1))]
                                            (false? (idx evaled_params i))           (recurse (+ 1 i))
                                            true                                     (idx evaled_params i))
             ) 0)
        )) or]]
        ; should make not a built in and then do here
        ; OR not - I think it will actually lower correctly partially evaled

        (needs_params_val_lambda pr-str)
        (needs_params_val_lambda str)
        (needs_params_val_lambda prn)
        (give_up_eval_params println)
        ; really do need to figure out if we want to keep meta, and add it if so
        (give_up_eval_params meta)
        (give_up_eval_params with-meta)
        ; if we want to get fancy, we could do error/recover too
        (give_up_eval_params error)
        (give_up_eval_params recover)
        (needs_params_val_lambda read-string)
        (give_up_eval_params slurp)
        (give_up_eval_params get_line)
        (give_up_eval_params write_file)
        ['empty_env ['env true nil [nil]]]
        nil
    ] root_env]

    partial_eval (lambda (x) (partial_eval_helper (mark x) root_marked_env [] 0))
)
    (provide partial_eval strip print_strip)
))
